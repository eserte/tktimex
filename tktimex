#!/usr/local/bin/perl -w
# -*- perl -*-

#
# $Id: tktimex,v 4.61 2000/08/29 17:29:34 eserte Exp $
#
# Author: Slaven Rezic
# Copyright: see in subroutine show_about or the Help/About menu entry
#            (it's basically a BSD-styled copyright)
#
# Mail: mailto:eserte@cs.tu-berlin.de
# WWW:  http://user.cs.tu-berlin.de/~eserte/
#

#use blib qw(/home/e/eserte/src/perl/Devel-SRT);
#use Devel::SRT;

BEGIN {
    sub state_change { }
    state_change("before Tk");
}
use Tk;
BEGIN {
    state_change("after Tk");
}
use Tk::ErrorDialog;

state_change("all use's processed...");

######################################################################

package Tk::Wm;

sub Popup
{
 my $w = shift;
 $w->withdraw;        # force invisible update
 $w->configure(@_) if @_;
 $w->idletasks;
 my ($mw,$mh) = ($w->reqwidth,$w->reqheight);
 my ($rx,$ry,$rw,$rh) = (0,0,0,0);
 my $base    = $w->cget('-popover');
 my $outside = 0;
 if (defined $base)
  {
   if ($base eq 'cursor')
    {
     ($rx,$ry) = $w->pointerxy;
    }
   else
    {
     $rx = $base->rootx;
     $ry = $base->rooty;
     $rw = $base->Width;
     $rh = $base->Height;
    }
  }
 else
  {
   my $sc = ($w->parent) ? $w->parent->toplevel : $w;
   $rx = -$sc->vrootx;
   $ry = -$sc->vrooty;
   $rw = $w->screenwidth;
   $rh = $w->screenheight;
  }
 my ($X,$Y) = AnchorAdjust($w->cget('-overanchor'),$rx,$ry,$rw,$rh);
 ($X,$Y)    = AnchorAdjust($w->cget('-popanchor'),$X,$Y,-$mw,-$mh);

 my ($sh,$sw) = ($w->screenheight, $w->screenwidth);
 $mw += 6; $mh += 28; # XXX for window manager frame
 if ($X + $mw > $sw) { $X = $sw - $mw }
 if ($X < 0)         { $X = 0         }
 if ($Y + $mh > $sh) { $Y = $sh - $mh }
 if ($Y < 0)         { $Y = 0         }

 $w->deiconify;
 $w->Post($X,$Y);
 $w->waitVisibility;
}

######################################################################

package main;

use Tk::HList;
BEGIN { state_change("after Tk::HList"); }
use File::Basename;
use FindBin;
use lib ("$FindBin::RealBin");
eval { require Tk::UnderlineAll };
BEGIN { state_change("before Timex::Project"); }
use Timex::Project;
BEGIN { state_change("after Timex::Project"); }
use strict;
use vars qw($VERSION);
use locale; # for sort, broken in older FreeBSD
BEGIN { state_change("after use locale"); }
# enable DnD
use Tk::DropSite;
BEGIN { state_change("after Tk::DropSite"); }

$VERSION = sprintf("%d.%02d", q$Revision: 4.61 $ =~ /(\d+)\.(\d+)/);

my $os = ($^O eq 'MSWin32' || $^O eq 'os2' ? 'win' : 'unix');
my $can_lock = ($^O ne 'MSWin32'); # gefährlich für win...
my $lock_is_strict = ($os eq 'win');
my $file_writeable;

if ($Tk::VERSION <= 402.002) {
    Tk::HList->EnterMethods("Tk/HList.pm", qw(header));
}

my $root = new Timex::Project;

my $quit_dialog;
my $title = "tktimex $VERSION";
my $current_project = undef;
my $is_opened;
my $start_session_time = time;
my $time_after;
my $time_update = 0;
my $autosave_after;
my @nowtime = localtime;
my $today_time = time - $nowtime[0] - $nowtime[1]*60 - $nowtime[2]*60*60;
my $project_status = "Left: Select | Middle: Create Subproject | Right: Attributes";
my $status_text;
# there are two forms of separators: for intern store in HList
# use $separator, for human-readable output use "/"
my $separator = '¦';
my $undo_register;
my $status_edit = 0;
my $last_projects;
my $max_last_projects = 4;
my $home = get_home_dir();
my $inner_fg = "black";
my $inner_bg = "white";
my %history;
my(%rcs_cache, @rcs_cache);
my $ctrl_s = ($os eq 'win' ? 'Ctrl-' : 'C-');
my $sbside = ($os eq 'win' ? 'e' : 'w');

state_change("before Getopt definition");

my $options = {};
my @opttable =
  ('General',
   ['file|f',             '=s', undef, 'subtype' => 'file',
    'longhelp' => "Default project file to load on startup"],
   ['lock',               '!',  1,
    'longhelp' => "Set to false if you don't want file locking."],
   ['one-instance',     '!',  0,
    'longhelp' => "Exit application if there is already another instance running"],
   ['autosave',           '!',  1,
    'callback' => \&toggle_autosave, 'alias' => ['as'],
    'longhelp' => "Autosave is recommended!"],
   ['update',             '=i', 60*10,
    'longhelp' => "Autosave interval in seconds."],
   ['oneday-immediately', '!',  1,
    'longhelp' => "Daily details: immediate update if changing date"],
   ['geometry',           '=s', "500x230",
    'longhelp' => "Size of window on startup"], # XXX
   ['securesave',         '!', 0,
    'longhelp' => "Saving data also in a Data::Dumper format. Not really necessary anymore."],

   'Projects',
   ['dateformat',         '=s', 'h',
    'choices' => ['d', 'h', 'hs', 'frac d', 'frac h'],
    'strict' => 1,
    'callback' => \&set_dateformat,
    'alias' => ['df'],
    'longhelp' => "Format of time display",
    ],
   ['day8',               '!',  0, 'callback' => \&toggle_time_arbeitstag,
    "longhelp" => "If set: a day should be treated as 8 hours."],
   ['archived',           '!',  0, 'callback' => \&toggle_show_archived,
    "longhelp" => "Show archived projects too.",
    ],
   ['onlytop',            '!',  0, 'callback' => \&toggle_show_archived,
    "longhelp" => "Do not show subprojects.",
    ],
   ['sort',               '=s', '',
    'choices' => ['nothing', 'name', 'time'],
    'strict' => 1,
    'callback' => \&insert_all,
   ],

   'Appearance',
   ['busyind',            '!', 0,
    'longhelp' => 'Show a busy indicator if a project is running'],
   ['autoscroll',         '=s', 'none',
    'choices' => ['slow', 'normal', 'fast'],
    'strict' => 1,
    'longhelp' => "Autoscrolling is not available on all systems.\n" .
    "Changes are effective on restart."
    ],
   ['hourlyrate',         '=f', 0,
    'callback' => sub { update_costs_option(1) },
    'longhelp' => "Hourly rate for work.",
    ],
   ['currency',           '=s', "DEM",
    'choices' => ['EUR', 'USD', 'HRD'],
    'callback' => sub { update_costs_option(1) },
    'longhelp' => "Currency for hourlyrate option.",
    ],
  );
my $opt;
eval {
    state_change("before require Tk::Getopt");
    require Tk::Getopt;
    Tk::Getopt->VERSION(0.34);
    state_change("after require Tk::Getopt");
};
if ($@) {
    warn "No Tk::Getopt --- falling back to Getopt::Long\n";
    require Getopt::Long;
    my @getopt;
    push @getopt, $options;
    foreach (@opttable) {
	if (ref $_ eq 'ARRAY') {
	    $options->{$_->[0]} = $_->[2] if defined $_->[2];
	    push @getopt, $_->[0] . $_->[1];
	}
    }
    die "Usage?" if !Getopt::Long::GetOptions(@getopt);
} else {
    state_change("Tk::Getopt checkpoint 1");
    $opt = new Tk::Getopt(-opttable => \@opttable,
			  -options  => $options,
			  -filename => "$home/.tktimexrc");
    state_change("Tk::Getopt checkpoint 2");
    $opt->set_defaults;
    state_change("Tk::Getopt checkpoint 3");
    $opt->load_options;
    require Getopt::Long; state_change("Tk::Getopt checkpoint 4");
    die $opt->usage if !$opt->get_options;
    state_change("Tk::Getopt checkpoint 5");
}
if (@ARGV) {
    $options->{'file'} = shift @ARGV;
}

state_change("checkpoint 1");

if ($options->{'one-instance'} and tktimex_running()) {
    require Tk::Dialog;
    my $top = tkinit;
    $top->withdraw;
    $top->Dialog(-title => 'Error',
		 -text => "Another tktimex instance is already running.\n" .
		 "Start tktimex with the option -noone-instance, if you\n" .
		 "want really two instances of this program running.\n",
		 -popover => 'cursor')->Show;
    exit;
}

my $top = new MainWindow;
$top->protocol('WM_DELETE_WINDOW', \&quit_program);
$top->protocol('WM_SAVE_YOURSELF',
	       sub { save_sos();
		     # XXX andere Optionen mit speichern (?)
		     $top->command("$^X $0 $options->{'file'}");
		     $top->destroy;
		 });
# SIGHUP is not defined on Windows
eval {
    local $^W = undef;
    $SIG{'HUP'} = sub { save_sos(); };
};

$top->title($title);
$top->geometry($options->{'geometry'}) if $options->{'geometry'};
eval {
    my $icon = $top->Pixmap(-file => Tk::findINC("mini-clock.xpm"));
    $top->Icon(-image => $icon);
};

state_change("checkpoint 2");

my($is_archiv, $east);
my $balloon;
if ($Tk::VERSION >= 800.005) {
    require Tk::ItemStyle; # erst ab 800.005
    $is_archiv = $top->ItemStyle('text', -foreground => 'red',
				 -background => $inner_bg);
    $east = $top->ItemStyle('text', -anchor => 'e',
			    -background => $inner_bg,
			    -foreground => $inner_fg);

    # altes Balloon und HList vertragen sich nicht miteinander
    require Tk::Balloon;
    $balloon = $top->Balloon;
}

state_change("menu begin");

my $menu_frame = $top->Frame(-relief => 'raised',
			     -borderwidth => 2);

my $mb_file = $menu_frame->Menubutton(-text => 'File')->pack(-side => 'left');
state_change("first menubutton loaded");
$mb_file->command(-label => 'Load',
		  -command => sub { load_file(1) });
$mb_file->command(-label => 'Save',
		  -command => \&save_file);
$mb_file->cascade(-label => 'Export');
my $mb_file_menu = $mb_file->cget(-menu);
my $mb_export = $mb_file_menu->Menu;
$mb_file->entryconfigure('last', -menu => $mb_export);
$mb_export->command(-label => 'Save as ...',
		    -command => \&save_as_file);
$mb_export->command(-label => 'Save skeleton',
		    -command => \&save_skeleton);
$mb_export->command(-label => 'Save subproject',
		    -command => \&save_subproject);
$mb_export->command(-label => 'Save XML',
		    -command => \&save_xml);
$mb_export->command(-label => 'Save Excel',
		    -command => sub {
			require Timex::ExcelExport;
		        Timex::ExcelExport::save_dialog
				($top, $root,
				 -hourlyrate => $options->{'hourlyrate'},
				);
		    });
$mb_export->command(-label => 'Dump',
		    -command => \&dump_data);
$mb_file->command(-label => 'Merge',
		  -command => \&merge_file);
$mb_file->command(-label => 'Quit',
		  -command => \&quit_program);
$mb_file->separator;

my $mb_project = $menu_frame->Menubutton(-text => 'Project'
					)->pack(-side => 'left');
$mb_project->command(-label => 'New',
		     -command => \&new_project);
$mb_project->command(-label => 'New subproject',
		     -command => sub { new_sub_project(get_sel_entry()) });
$mb_project->command(-label => 'Delete',
		     -command => \&delete_project);
## Menü ist zu überladen...
#$mb_project->command(-label => 'Pause',
#		     -command => \&pause_or_cont);
$mb_project->command(-label => 'Undo',
		     -command => \&undo);
$mb_project->command(-label => 'Search',
		     -command => \&search_project,
		     -accelerator => $ctrl_s . 's');
$top->bind('<Control-s>' => \&search_project);
$mb_project->command(-label => 'Continue last',
		     -command => \&cont_last);
$mb_project->command(-label => 'Attributes',
		     -command => sub { show_attributes(undef) });
$mb_project->command(-label => 'Intervals',
		     -command => sub { show_intervals($top, undef) },
		     -accelerator => $ctrl_s .'i');
$top->bind('<Control-i>' => sub { show_intervals($top, undef) });
## Menü ist zu überladen...
#$mb_project->command(-label => 'Note',
#		     -command => sub { show_note($top) });
$mb_project->separator;
$mb_project->command(-label => 'Working time',
		     -command => \&working_time);
$mb_project->command(-label => 'Daily details',
		     -command => \&show_one_day,
		     -accelerator => $ctrl_s . 'd');
$top->bind('<Control-d>' => \&show_one_day);

my $mb_project_menu = $mb_project->cget(-menu);

my $mb_options = $menu_frame->Menubutton(-text => 'Options'
					)->pack(-side => 'left');
$mb_options->checkbutton(-label => 'Autosave',
			 -command => \&toggle_autosave,
			 -variable => \$options->{'autosave'},
			);
$mb_options->cascade(-label => 'Dateformat');
my $mb_options_menu = $mb_options->cget(-menu);
my $dateformat_menu = $mb_options_menu->Menu;
$mb_options->entryconfigure('Dateformat', -menu => $dateformat_menu);
$mb_options->checkbutton(-label => 'day = 8h',
			 -command => \&toggle_time_arbeitstag,
			 -variable => \$options->{'day8'},
			);
$mb_options->checkbutton(-label => 'Show archived',
			 -command => \&toggle_show_archived,
			 -variable => \$options->{'archived'},
			);
$mb_options->checkbutton(-label => 'Show only top',
			 -command => \&toggle_show_only_top,
			 -variable => \$options->{'onlytop'},
			);
if (defined $opt) {
    $mb_options->separator;
    $mb_options->command(-label => 'Option editor',
			 -command => sub { $opt->option_editor($top) });
}

foreach my $def (['H:M:S'  => 'hs'],
		 ['H:M'    => 'h'],
		 ['d H:M'  => 'd'],
		 ['Frac H' => 'frac h'],
		 ['Frac d' => 'frac d'],
		) {
    $dateformat_menu->radiobutton(-label => $def->[0],
				  -command => \&set_dateformat,
				  -value => $def->[1],
				  -variable => \$options->{'dateformat'},
				 );
}

my $mb_help = $menu_frame->Menubutton(-text => 'Help'
				     )->pack(-side => 'left');
$mb_help->command(-label => 'About',
		  -command => \&show_about);
$mb_help->command
  (-label => 'Index',
   -command => sub {
       eval {
	   require Tk::Pod;
	   Tk::Pod->Dir($FindBin::Bin);
	   $top->Pod(-file => "$FindBin::Script",
		     -title => "tktimex",
		    );
       };
       $status_text->configure(-text => substr($@, 0, 40) . "...") if $@;
   });

state_change("menu done");

my $save_check;
my($mod_watch, $mod_sub);
# Aus mir völlig unerklärlichen Gründen muß sich mod_sub außerhalb
# des evals befinden (perl5.00404)
$mod_sub = sub {
    my($self, $newval) = @_;
    if ($newval) {
	$save_check->configure(-bg => 'red');
    } else {
	$save_check->configure(-bg => 'green');
    }
    $self->Store($newval) if $self;
};
eval {
    die;
    require Tie::Watch;
    # earlier versions used Delete instad of Unwatch:
    Tie::Watch->VERSION(0.99);
    $save_check = $menu_frame->Label(-padx => 4, -relief => 'raised');
 
    $mod_watch = Tie::Watch->new(-variable => \$root->{'modified'},
				 -store => $mod_sub,
				);
    $mod_sub->();
};
if (!$mod_watch || $@) {
    $save_check = $menu_frame->Checkbutton
    (-variable => \$root->{'modified'},
     ($os ne 'win' ? (-selectcolor => "red") : ()),
     -highlightthickness => 0,
     -padx => 0, -pady => 0,
     #-font => "times 5",
    );
    $save_check->bindtags([]);
}
$save_check->pack(-side => 'right');
$balloon->attach($save_check, -msg => 'Timex data modified indicator')
  if $balloon;

my $pause_cont_button = $menu_frame->Button
  (-text => 'Pause',
   -fg => 'red',
   -width => 5,
   -command => \&pause_or_cont)->pack(-side => 'right');

my $save_button = $menu_frame->Button(-text => 'Save',
				      -fg => 'yellow4',
				      -command => \&save_file
				     )->pack(-side => 'right');
$balloon->attach($save_button, -msg => 'Save project data') if $balloon;
 
my $minimized = 0;
my $save_geometry;
my($up_photo, $down_photo);
eval {
    $up_photo   = $top->Photo(-file => Tk::findINC("plain.up.gif"));
    $down_photo = $top->Photo(-file => Tk::findINC("plain.down.gif"));
};
warn $@ if $@;
my $min_button = $menu_frame->Button(-image => $up_photo,
				     -command => \&minmaximze,
				     -relief => 'flat',
				    )->pack(-side => 'right');
$balloon->attach($min_button, -msg => 'Minimize') if $balloon;
my $busy_timer;
my @busy_bar = ('|', '/', '-', '\\');
my $busy_index = 0;
my $busy_string = " ";
my $busy_update = 200;
my $busy_label = $menu_frame->Label(-textvariable => \$busy_string,
                                    -width => 1)->pack(-side => 'right');

$menu_frame->pack(-fill => 'x');

state_change("menu 2 done");

my($pf_cols, $has_costs);
$pf_cols = 5; # cannot change -columns of hlists...

state_change("checkpoint 3");

my $project_frame = $top->Scrolled
  ('HList', -scrollbars => "oso$sbside",
   -bg => $inner_bg,
   -fg => $inner_fg,
   -columns => $pf_cols,
   -height => 1,
   -drawbranch => 1,
   -header => 1,
   -selectmode => 'single',
   -browsecmd => sub {
       pause();
       update_pause_cont_balloon();
   },
   -separator => $separator,
  )->pack(-expand => 1, -fill => 'both');

state_change("checkpoint 4");
if ($options->{'autoscroll'} !~ /^(|none)$/) {
    require Tk::Autoscroll;
    Tk::Autoscroll::Init($project_frame, -speed => $options->{'autoscroll'});
}
$project_frame->header('create', 0, -text => 'Projects:');
my $pf_time_index = 1;
$project_frame->header('create', $pf_time_index, -text => 'Session');
$project_frame->header('create', $pf_time_index+1, -text => 'Today');
$project_frame->header('create', $pf_time_index+2, -text => 'Total');
update_costs_option(1);

state_change("checkpoint 5");

my $orig_selectbg = $project_frame->cget(-selectbackground);

foreach my $ev (qw(Double-ButtonRelease-1
		   Return)) {
    $project_frame->bind("<$ev>" =>
			 sub { start_stop(shift->info('selection')) });
}
if ($options->{'autoscroll'} =~ /^(|none)$/) {
    $project_frame->bind("<Button-2>" =>
			 sub { new_sub_project(get_entry(@_)) });
}
#XXX evtl. für Win32 aktivieren (häufig Button2 = Doppelklick)
#Problem: Single-Button-1 wird auch ausgeführt :-(
# und weitere Probleme...
if (0 && $os eq 'win') {
    $project_frame->bind("<Double-Button-1>" =>
			 sub { new_sub_project(get_entry(@_)); Tk->break });
}
$project_frame->bind("<Button-3>" =>
                     sub { show_attributes(get_entry(@_)) });

state_change("checkpoint 6");

if ($project_frame->can('DropSite')) {
    eval {
	$project_frame->DropSite
	  (-dropcommand => [\&accept_drop, $project_frame],
	   -droptypes => ($os eq 'win' ? 'Win32' : ['KDE', 'XDND', 'Sun']));
    };
}

my $status_frame = $top->Frame(-relief => 'ridge',
			       -bd => 1);
$status_frame->pack(-fill => 'x');

$status_text = $status_frame->Label
  (-text => "Current file: " . ($options->{file} || ""));
$status_text->pack(-side => 'left');

state_change("checkpoint 7");

# verzögert zeigen, da evtl. wichtige Statusmeldungen dadurch
# verdeckt werden ... aber nicht, wenn in der Statuszeile editiert wird!
my $status_timer;
$project_frame->bind
  ("<Enter>" => sub {
       if ($status_timer) {
	   $status_timer->cancel;
	   undef $status_timer;
       }
       $status_timer = $project_frame->after
	 (3000, sub { $status_text->configure(-text => $project_status)
			unless $status_edit;
		  })
     });
$project_frame->bind
  ("<Leave>" => sub {
       if ($status_timer) {
	   $status_timer->cancel;
	   undef $status_timer;
       }
       $status_timer = $project_frame->after
	 (3000, sub { $status_text->configure
			(-text => "Current file: " . ($options->{file} || ""))
			  unless $status_edit;
		  })
     });

$menu_frame->UnderlineAll if $menu_frame->can('UnderlineAll');

$opt->process_options if defined $opt;

state_change("checkpoint 8");

set_time_update();

$root->modified(0);

state_change("checkpoint 9");

if ($options->{'file'}) {
    load_file(0);
    $last_projects = [ $root->last_projects($max_last_projects) ];
    create_menu_last_projects();
}

$project_frame->focus;

$top->repeat(5*60*1000, \&check_still_today);

state_change("before MainLoop");
MainLoop;

sub enter_label {
    my $label = shift;
    my $caller = shift;
    my $action;
    my $res = '';
    $status_edit++;
    $status_text->configure(-text => $label);
    my $Entry = "Entry";
    my @extra_args;
    my $this_history_file;
    eval {
	require Tk::HistEntry;
	Tk::HistEntry->VERSION(0.33);
	$Entry = "SimpleHistEntry";
	@extra_args = (-match => 1, -dup => 0);
	$this_history_file = "$home/.tktimex_hist";
    };
    my $entry = $status_frame->$Entry(-bg => $inner_bg,
				      -fg => $inner_fg,
				      -textvariable => \$res,
				      -width => 30,
				      @extra_args);

    $entry->bindtags(['Tk::HistEntry::Simple', $entry]);
    if ($entry->can('historyMergeFromFile')) {
	$entry->historyMergeFromFile($this_history_file);
    } elsif ($entry->can('history') and ref $history{$caller} eq 'ARRAY') {
	$entry->history($history{$caller});
    }

    $entry->pack(-side => 'left');
    $entry->waitVisibility;
    $entry->grab;
    $entry->focus;
    $entry->bind("<Return>", sub { $action = 'yes' });
    $entry->bind("<Escape>", sub { $action = 'no' });
    $entry->OnDestroy(sub { $status_edit-- });
    $entry->waitVariable(\$action);
    $entry->grabRelease;

    # Muss vor $entry->destroy kommen!
    if ($action eq 'yes') {
	if ($entry->can('historyAdd')) {
	    $entry->historyAdd();
	    if ($entry->can('historySave')) {
		$entry->historySave($this_history_file);
	    } else {
		$history{$caller} = [ $entry->history ];
	    }
	}
    }

    $entry->destroy;
    $status_text->configure(-text => "Current file: " .
			    ($options->{file} || ""));
    $project_frame->focus;
    if ($action eq 'yes') {
	$res =~ s/$separator//g; # sicherheitshalber ...
	$res;
    } else {
	undef;
    }
}

BEGIN { state_change("parsed 26%"); }

sub exists_project {
    my $path = shift;
    if (defined $root->find_by_pathname($path)) {
	require Tk::Dialog;
	$top->Dialog
	    (-title => 'Error',
	     -text => 'A project labeled ' . $path . ' already exists!',
	     -popover => 'cursor',
	     )->Show;
	return 1;
    }
    0;
}

sub new_project {
    my $label = enter_label('New project name:', 'newproject');
    if ($label && $root) {
	return if exists_project($label);
	my $p = $root->subproject($label);
	insert_project($p);
	$project_frame->see(make_path($p));
    }
}

sub new_sub_project {
    my $path = shift;
    return if !defined $path;
    my $label = enter_label('New subproject name:', 'newproject');
    if ($label) {
	my $p = entry_to_project($path);
	return if !$p;
	my $path = $p->pathname . $separator . $label;
	return if exists_project($path);
	my $sub_p = $p->subproject($label);
	insert_project($sub_p);
	$project_frame->see(make_path($sub_p));
    }
}

sub delete_project {
    my $path = shift || $project_frame->info('selection');
    return unless $path;
    return if !$project_frame->info('exists', $path);
    my $p = $project_frame->info('data', $path);
    return if !$p;
    return if !not_running(undef, $p);
    require Tk::Dialog;
    my $ans = $top->Dialog
      (-title => 'Warning',
       -text  =>
       "Do you really want to delete the project " . $p->pathname
       . " and all its subprojects?",
       -popover => 'cursor',
       -buttons => ['Yes', 'No'],
       -default_button => 'No',
      )->Show;
    return if $ans ne 'Yes';
    $p->delete;
    insert_all();
}

sub insert_project {
    my($p) = @_;
    return if !$p || ($p->archived && !$options->{'archived'});
    my $label = $p->label;
    my $path = make_path($p);
    return if !$path;
    if ($project_frame->info('exists', $path)) {
	warn "Duplicate entry path $path - please check .pj1 file!";
	return;
    }
    $project_frame->add($path,
			-text => $p->label,
			-itemtype => 'text',
			-data => $p);
    if ($p->archived && $is_archiv) {
	$project_frame->itemConfigure($path, 0, -style => $is_archiv);
    }
    my $all_time_sec = $p->sum_time(0, undef, -recursive => 1);
    $project_frame->itemCreate
      ($path, $pf_time_index, -itemtype => 'text',
       -text => sec2time($p->sum_time($start_session_time, undef,
				      -recursive => 1)));
    $project_frame->itemCreate
      ($path, $pf_time_index+1, -itemtype => 'text',
       -text => sec2time($p->sum_time($today_time, undef,
				      -recursive => 1)));
    $project_frame->itemCreate
      ($path, $pf_time_index+2, -itemtype => 'text',
       -text => sec2time($all_time_sec));

    if ($has_costs) {
	my $hours = int($all_time_sec/3600);
	$hours += ($all_time_sec%3600 > 0 ? 1 : 0);
	$project_frame->itemCreate
	    ($path, $pf_time_index+3, -itemtype => 'text',
	     -text => sprintf("%.2f", $hours*$options->{'hourlyrate'}));
    }

    for ($pf_time_index .. $pf_time_index+($has_costs?3:2)) {
	$project_frame->column('width', $_, '');
	if ($east) {
	    $project_frame->itemConfigure($path, $_, -style => $east);
	}
    }
}

sub start_stop {
    my $path = shift;
    if ($path && ref $path and $path->isa('Timex::Project')) {
	$path = $path->pathname($separator);
    }
    return if !$project_frame->info('exists', $path);
    my $p = $project_frame->info('data', $path);
    return if !$p;
    if (defined $current_project && $current_project eq $p) {
	pause_or_cont();
    } else {
	start_project($p);
    }
}

sub common_start_project {
    my $p = shift;
    stop_project();
    $current_project = $p;
    my $current_pathname = $p->pathname($separator);
    $project_frame->selectionClear;
    $project_frame->selectionSet($current_pathname);
    $project_frame->anchorSet($current_pathname);
    $project_frame->configure(-selectbackground => 'SeaGreen3');
    $project_frame->see($current_pathname);
    gui_set_pause_or_cont('Pause');

    $top->title($title . " (" . $p->pathname . ")");
    add_last_projects($current_project);

    if (defined $busy_timer) {
	$busy_timer->cancel;
    }
    if ($options->{'busyind'}) {
	$busy_timer = $project_frame->repeat
	    ($busy_update, sub {
		$busy_index = ($busy_index >= $#busy_bar ? 0 : $busy_index+1);
		$busy_string = $busy_bar[$busy_index];
	    });
    }

    set_timeout();
}

sub start_project {
    my $p = shift;
    common_start_project($p);
    $p->start_time;
}

sub pause {
    if (defined $current_project) {
	stop_project();
	gui_set_pause_or_cont('Cont');
    }
}

sub pause_or_cont {
    if (defined $current_project) {
	stop_project();
	gui_set_pause_or_cont('Cont');
    } else {
	my $p = get_project_from_selection();
	return if !$p;
	start_project($p);
    }
}

sub cont_last {
    return if !not_running();
    my $p = get_project_from_selection();
    return if !$p || !@{$p->{'times'}};
    my $last = $p->{'times'}[$#{$p->{'times'}}];
    require Tk::Dialog;
    my $d = $top->Dialog
      (-title => 'Continue last',
       -text  => "Really continue time from last activity\n(" .
       $p->pathname . " started at " . scalar(localtime($last->[0])) . ") ?",
       -default_button => 'No',
       -buttons => ['Yes', 'No'],
       -popover => 'cursor',
      );
    return if $d->Show eq 'No';
    $p->unend_time;
    insert_all(); # XXX Optimierung: nur aktuelles Projekt modifizieren
    common_start_project($p);
}

sub get_project_from_selection {
    my $sel = $project_frame->selectionGet;
    if ($sel) {
	return $project_frame->info('data', $sel);
    }
    undef;
}

sub update_pause_cont_balloon {
    my $txt = $pause_cont_button->cget(-text);
    if ($txt eq 'Cont') { $txt = 'Continue' }
    if ($balloon) {
	my $p = get_project_from_selection();
	if ($p) {
	    $balloon->detach($pause_cont_button);
	    $balloon->attach($pause_cont_button,
			     -msg => $txt . " " . $p->pathname);
	}
    }
}

sub gui_set_pause_or_cont {
    my $txt = shift;
    $pause_cont_button->configure(-text => $txt,
				  -fg => ($txt eq 'Cont' ? 'green4' : 'red'));
    update_pause_cont_balloon();

}

sub stop_project {
    if (defined $time_after) {
	$time_after->cancel;
	undef $time_after;
    }
    if (defined $busy_timer) {
	$busy_timer->cancel;
	undef $busy_timer;
    }
    $busy_string = " ";
    if (defined $current_project) {
	$current_project->end_time;
	act_time();
	undef $current_project;
	if ($options->{'autosave'}) {
	    save_file(); # muß nach undef $current_project kommen!!!
	}
	$project_frame->configure(-selectbackground => $orig_selectbg);
	$top->title($title);
	create_menu_last_projects();
    }
}

sub undo {
    if (!defined $current_project) {
	require Tk::Dialog;
	$top->Dialog(-title => 'Info',
		     -text  => "No running project.",
		     -default_button => 'OK',
		     -buttons => ['OK'],
		     -popover => 'cursor',
		    )->Show;
	return;
    }

    require Tk::Dialog;
    my $d = $top->Dialog(-title => 'Undo',
			 -text  => "Really undo last start of "
			 . $current_project->pathname . "?",
			 -default_button => 'No',
			 -buttons => ['Yes', 'No'],
			 -popover => 'cursor',
			);
    return if $d->Show eq 'No';

    my $p = $current_project;
    stop_project();
    $undo_register = pop(@{$p->{'times'}});
    gui_set_pause_or_cont('Cont');
    act_time($p);
}

sub search_project {
    my $regex = enter_label("Search:", 'search');
    if ($regex && $root) {
	# XXX vielleicht ein eval, um regex-Fehler abzufangen; \Q/\E geht nicht
	my @res = $root->find_by_regex_pathname("(?i)$regex");
	foreach my $r (@res) {
	    my $path = make_path($r);
	    # überprüfen, ob das Projekt überhaupt sichtbar ist:
	    if ($project_frame->info('exists', $path)) {
		$project_frame->see($path);
		$project_frame->anchorSet($path);
		last;
	    }
	}
    }
}

sub act_time {
    my $p = shift;
    if (!$p) {
	$p = $current_project;
	return if !$p;
    }
    my $project = $p;
    while ($project) {
	act_time_project($project);
	$project = ($project->level > 1 ? $project->parent : undef);
    }
    set_timeout();
}

sub act_time_project {
    my($p) = @_;
    my $path = make_path($p);
    return if !$path;
    $project_frame->itemConfigure
      ($path, $pf_time_index,
       -text => sec2time($p->sum_time($start_session_time, undef,
				      -recursive => 1,
				      -usecache => 1)));
    $project_frame->itemConfigure
      ($path, $pf_time_index+1,
       -text => sec2time($p->sum_time($today_time, undef,
				      -recursive => 1,
				      -usecache => 1)));
    $project_frame->itemConfigure
      ($path, $pf_time_index+2,
       -text => sec2time($p->sum_time(0, undef,
				      -recursive => 1,
				      -usecache => 1)));
}

sub set_timeout {
    if (defined $time_after) {
	$time_after->cancel;
    }
    $time_after = $project_frame->after
      ($time_update*1000, sub { act_time(); } );
}

sub working_time {
    my $sum = 0;
    my $week_days = 7;
    my $week_work_days = 5;
    my $month_days = 7*4;
    my $month_work_days = 5*4;
    my $last_4week_time = $today_time - 86400*$month_days;
    my $last_week_time = $today_time - 86400*$week_days;
    my $yesterday_time = $today_time - 86400;
    my $last_4week_sum = 0;
    my $last_week_sum = 0;
    my $yesterday_sum = 0;
    foreach ($root->subproject) {
	my $project_today_time = $_->sum_time($today_time, undef,
					      -recursive => 1);
	$sum += $project_today_time;
	$yesterday_sum
	  += $_->sum_time($yesterday_time, undef,
			  -recursive => 1) - $project_today_time;
	$last_week_sum
	  += $_->sum_time($last_week_time, undef, -recursive => 1);
	$last_4week_sum
	  += $_->sum_time($last_4week_time, undef, -recursive => 1);
    }

    require Tk::DialogBox;
    my $d = $top->DialogBox(-title => 'Today\'s time',
			    -buttons => ['OK'],
			    -popover => 'cursor',
			   );
    my $gridy = 0;
    $d->add('Label',
	    -text => "Today\'s working time:")->grid(-row => $gridy,
						     -column => 0,
						     -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($sum, 'h', 0))->grid(-row => $gridy,
						   -column => 1,
						   -sticky => 'w');
    $gridy++;
    $d->add('Label',
	    -text => "Yesterday\'s working time:")->grid(-row => $gridy,
							 -column => 0,
							 -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($yesterday_sum, 'h', 0))->grid(-row => $gridy,
							     -column => 1,
							     -sticky => 'w');
    $gridy++;
    $d->add('Label')->grid(-row => $gridy, -column => 0);
    $gridy++;
    $d->add('Label',
	    -text => "Last week\'s working time (8h-day):"
	   )->grid(-row => $gridy,
		   -column => 0,
		   -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_week_sum, 'd', 1))->grid(-row => $gridy,
							     -column => 1,
							     -sticky => 'w');
    $gridy++;
    $d->add('Label',
	    -text => "  Average per working day:")->grid(-row => $gridy,
							 -column => 0,
							 -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_week_sum/$week_work_days, 'h', 0)
	   )->grid(-row => $gridy,
		   -column => 1,
		   -sticky => 'w');
    $gridy++;
    $d->add('Label')->grid(-row => $gridy, -column => 0);
    $gridy++;
    $d->add('Label',
	    -text => "Last 4 week\'s working time (8h-day): "
	   )->grid(-row => $gridy,
		   -column => 0,
		   -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_4week_sum, 'd', 1))->grid(-row => $gridy,
							      -column => 1,
							      -sticky => 'w');
    $gridy++;
    $d->add('Label',
	    -text => "  Average per working day:")->grid(-row => $gridy,
							 -column => 0,
							 -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_4week_sum/$month_work_days, 'h', 0)
	   )->grid(-row => $gridy,
		   -column => 1,
		   -sticky => 'w');
    $d->Show;
}

sub show_one_day {
    my($inner_bg_opt, $inner_fg_opt) = ('-bg', '-fg');
    eval {
	require Tk::Date;
	Tk::Date->VERSION(0.27);
	if ($Tk::Date::VERSION >= 0.30) {
	    ($inner_bg_opt, $inner_fg_opt) = ('-innerbg', '-innerfg');
	}
    };
    my $has_date = !$@;
    my $has_date_entry;
    if (!$has_date) {
	eval {
	    require Tk::DateEntry;
	};
	$has_date_entry = !$@;
	if (!$has_date_entry) {
	    require Time::Local;
	}
    }
    my $f = $top->Toplevel(-title => 'Show daily details');
    $f->{WindowType} = "Daily details";
    my $btn;
    my @p; # project array for one day
    my($dw, $dw_to);
    my $no_interval_cb;
    if ($has_date) {
	my $df = $f->Frame->pack;
	# from:
	$dw = $df->Date
	  ($inner_bg_opt => $inner_bg,
	   $inner_fg_opt => $inner_fg,
	   -fields => 'date',
	   -value => 'now',
	   -datefmt => "%12A, %2d.%2m.%4y",
	   -choices => [qw(today yesterday),
			['one week before' => sub {time()-86400*7}],
			['four weeks before' => sub { time()-86400*7*4}],
		       ],
	   -command => sub {
	       # XXX if chain button activated, adjust dw_to widget
	       if ($options->{'oneday-immediately'}) {
		   $btn->invoke;
	       }
	   }
	  )->grid(-row => 0, -column => 0, -sticky => "e");
	# to:
	$dw_to = $df->Date
	    ($inner_bg_opt => $inner_bg,
	     $inner_fg_opt => $inner_fg,
	     -fields => 'date',
	     -value => 'now',
	     -datefmt => "%12A, %2d.%2m.%4y",
	     -choices => [qw(today yesterday),
			  ['one week before' => sub {time()-86400*7}],
			  ['four weeks before' => sub { time()-86400*7*4}],
			 ],
	     -command => sub {
		 if ($options->{'oneday-immediately'}) {
		     $btn->invoke;
		 }
	     }
	    )->grid(-row => 1, -column => 0, -sticky => "e");
	my $c = $df->Canvas
	    (-width => 20,
	     -height => 40, #XXX$dw->reqheight + $dw_to->reqheight + 5,
	     -takefocus => 0,
	     -highlightthickness => 0,
	    )->grid(-row => 0, -column => 1, -rowspan => 2);
	$c->createLine(5,5, 10,5, 15,10, 15,30, 10,35, 5,35, # XXX verwendung von reqheight etc.
		       -width => 5, -smooth => 1);
	# XXX schöner machen
	my $orig_bg = $c->cget(-bg);
	$c->Tk::bind('<Enter>' => sub { $c->configure(-bg => 'grey80') }); # XXX
	$c->Tk::bind('<Leave>' => sub { $c->configure(-bg => $orig_bg) });
	$c->Tk::bind('<1>' => sub { $no_interval_cb->toggle });
    } else {
	if ($has_date_entry) {
	    $dw = $f->DateEntry
	      (-dateformat => 2,
	       -background => $inner_bg,
	       -foreground => $inner_fg,
	       -daynames => [qw/So Mo Di Mi Do Fr Sa/],
	       -weekstart => 1,
	      )->pack;
	} else {
	    $dw = $f->Entry(-bg => $inner_bg,
			    -fg => $inner_fg,
			   )->pack;
	    $dw->bind('<Return>' => sub {
			  if ($options->{'oneday-immediately'}) {
			      $btn->invoke;
			  }
		      });
	}
	my(@l) = localtime;
	$dw->insert(0, sprintf("%04d/%02d/%02d", $l[5]+1900, $l[4]+1, $l[3]));
    }
    my $ff = $f->Frame->pack;
    $btn = $ff->Button(-text => 'Show')->pack(-side => 'left');
    $f->{InvokeButton} = $btn;
    my $clb = $ff->Button(-text => 'Close',
			  -command => sub { $f->destroy },
			 )->pack(-side => 'left');
    $f->bind('<Escape>' => sub { $clb->invoke });
    $ff->Checkbutton(-text => 'immediately',
		     -variable => \$options->{'oneday-immediately'},
		     -command => sub {
			 $btn->invoke;
		     },
		     ($has_date_entry ? (-state => 'disabled') : ()),
		    )->pack(-side => 'left');
    my $one_day_only = 1;
    $no_interval_cb = 
	$ff->Checkbutton(-text => 'no interval',
			 -variable => \$one_day_only,
			 -command => sub {
			     if ($options->{'oneday-immediately'}) {
				 $btn->invoke;
			     }
			 },
			)->pack(-side => 'left');
    my $act_from_date; # current from date
    my $lb = $f->Scrolled('HList',
			  -bg => $inner_bg,
			  -fg => $inner_fg,
			  -columns => 2,
			  -width => 40,
			  -header => 1,
			  -scrollbars => "oso$sbside",
			  -selectmode => 'extended',
			  -exportselection => 1,
			  -command => sub {
			      show_intervals($f, $p[$_[0]],
					     -day => $act_from_date)
			  },
			 )->pack(-expand => 1,
				 -fill => 'both');
    $btn->configure(-command => sub {
		      my $s_from;
		      if ($has_date) {
			  $s_from = $dw->get("%s");
			  $s_from = Tk::Date::_begin_of_day($s_from);
		      } else {
			  my $s = $dw->get;
			  my($y,$m,$d) = split(/\D/, $s);
			  return if !($d >= 1 && $d <= 31 &&
				      $m >= 1 && $m <= 12 &&
				      defined $y);
			  $y -= 1900 if $y > 1900;
			  $s_from = Time::Local::timelocal(0, 0, 0,
							   $d, $m-1, $y);
		      }
		      $act_from_date = $s_from;
		      my $s_to = $s_from + 86399;
		      if ($has_date && !$one_day_only) {
			  $s_to = $dw_to->get("%s");
			  $s_to = Tk::Date::_begin_of_day($s_to)+86399;
		      }
		      if ($has_date) {
			  $dw_to->configure(-value => $s_to);
		      }
		      @p = $root->projects_by_interval($s_from, $s_to);
		      $lb->delete('all');
		      my $i = 0;
		      my $sum = 0;
		      foreach (@p) {
			  $lb->add($i, -text => $_->pathname);
			  my $diff = $_->sum_time($s_from, $s_to);
			  $sum += $diff;
			  $lb->itemCreate($i, 1, -text =>
					  sec2time($diff, undef, undef));
			  $i++;
		      }
		      $lb->header('create', 0, -text => '*** sum ***');
		      $lb->header('create', 1, -text =>
				  sec2time($sum, undef, undef));
		  });

    if ($has_date) {
	my $di = $lb->Button
	  (-text => "Daily intervals",
	   -command => sub {
	       my $begin_date = $dw->get("%s");
	       $begin_date = Tk::Date::_begin_of_day($begin_date);
	       daily_intervals($begin_date, $begin_date+86400);
	   },
	   -padx => 0, -pady => 0);
	$di->place(-rely => 1, '-y' => -$di->reqheight,
		   -relx => 1, '-x' => -$di->reqwidth); # XXX place!
    }
    if ($options->{'oneday-immediately'}) { $btn->invoke }
    $f->Popup(-popover => 'cursor');
}

sub daily_intervals {
    my($begin_date, $end_date) = @_;
    require POSIX;
    my $t = $top->Toplevel;
    $t->title(POSIX::strftime("%Y-%m-%d", localtime $begin_date));
    my $lb = $t->Scrolled('HList', -scrollbars => "oso$sbside",
			  -columns => 3,
			  -width => 60,
			 )->pack(-expand => 1, -fill => 'both');
    my @res_times = $root->restricted_times($begin_date, $end_date);
    my $i = 0;
    foreach (@res_times) {
	my $name = $_->[0]->pathname;
	if (length($name) > 40) {
	    $name = "... " . substr($name, -36); #length($name)-36
	}
	$lb->add($i, -text => $name);
	$lb->itemCreate($i, 1, 
			-text => POSIX::strftime("%H:%M:%S", localtime $_->[1])
		       );
	$lb->itemCreate($i, 2, 
			-text => POSIX::strftime("%H:%M:%S", localtime $_->[2])
		       );
	$i++;
    }
}

sub load_file {
    my $interactive = shift;
    my $file_to_load = shift;

    if ($root->modified || defined $current_project) {
	require Tk::Dialog;
	my $dialog = $top->Dialog(-title => 'Load',
				  -text  => "Load project data (overwrite current data)?",
				  -default_button => 'No',
				  -buttons => ['Yes', 'No'],
				  -popover => 'cursor',
				 );
	return if $dialog->Show eq 'No';
    }
    stop_project();

    if (!defined $file_to_load) {
	$file_to_load = $options->{'file'};
    }

    if ($interactive) {
	my($file, $path) = fileparse($options->{'file'});
	if ($path =~ m|^\.|) {
	    require Cwd;
	    $path = Cwd::abs_path($path);
	}

	$file_to_load = get_filename($top,
				     -Title  => 'Enter project file',
				     -File   => $file,
				     -Path   => $path,
				     -FPat   => '*.pj1',
				     -Create => 0);
	return if !$file_to_load;
    }

    if ($is_opened and $lock_is_strict) {
	unlock_file_temp();
    }

    $root->delete_all;
    if (!lock_file($file_to_load)) {
	$options->{'file'} = '';
	return;
    }

    my $sos_file = sos_filename($file_to_load);
    if (-f $sos_file) {
	my $mtime = (stat($sos_file))[9];
	require Tk::Dialog;
	$top->Dialog
	  (-title => 'Warning',
	   -text => "There is a sos file <$sos_file>\n".
	   "from " . scalar(localtime($mtime)) . ".\n".
	   "You should check whether this file contains valueable information.\n".
	   "Otherwise delete the file to avoid this warning.",
	   -popover => 'cursor',
	   -default_button => 'OK',
	   -buttons => ['OK'])->Show;
    }

    my $load_root = new Timex::Project;
    unlock_file_temp() if $lock_is_strict;
    my $ok = 1;
    if (!$load_root->load($file_to_load)) {
	$status_text->configure(-text => $@);
	$ok = 0;
    }
    return unless $ok;
    $file_writeable = -w $file_to_load;
    if (!$file_writeable) {
	require Tk::Dialog;
	$top->Dialog
	    (-title => 'Warning',
	     -text => 'The file ' . $file_to_load . ' is not writeable!',
	     -popover => 'cursor',
	     )->Show;
    }
    lock_file($file_to_load) if $lock_is_strict;

    $root = $load_root;
    $options->{'file'} = $file_to_load;

    $status_text->configure(-text => "Loaded $options->{file}");
    insert_all();
    set_autosave();
    $root->modified(0);
    if ($mod_watch) {
	$mod_watch->Unwatch;
	$mod_watch = Tie::Watch->new(-variable => \$root->{'modified'},
				     -store => $mod_sub,
				    );
	$mod_sub->();
    } else {
	$save_check->configure(-variable => \$root->{'modified'});
    }
    my $last_project = $root->last_project;
    if ($last_project) {
	my $last_project_path = make_path($last_project);
	if ($project_frame->info('exists', $last_project_path)) {
	    $project_frame->selectionSet($last_project_path);
	    $project_frame->see($last_project_path);
	    gui_set_pause_or_cont('Cont');
	}
    }
}

BEGIN { state_change("parsed 54%"); }

sub load_file_noninteractive {
    my $file = shift;
    load_file(0, $file);
}

sub lock_file {
#warn "file=$_[0] lock:$can_lock";
    if (!$can_lock || !$options->{'lock'}) {
	return 1;
    }
    my $file = shift;
    if (!$is_opened) {
#warn "not opened";
	eval q{
	    use Fcntl qw(:flock);
	    flock CURRFILE, LOCK_UN;
	};
	warn $@ if $@;
	close CURRFILE;
	$is_opened = 0;
    }
    my $lock_ok = 0;
    if (open(CURRFILE, $file)) {
	$is_opened = 1;
#warn "opend";
	eval q{
	    use Fcntl qw(:flock);
#warn "try flock";
	    if (!flock CURRFILE, LOCK_EX|LOCK_NB) {
		use Tk::Dialog;
		$top->Dialog
		  (-title => 'File locked',
		   -text  => "<$file> is already locked.\n" .
		   "Please check that there is no other tktimex process\n" .
		   "using this file and try again.\n",
		   -default_button => 'OK',
		   -buttons => ['OK'],
		   -popover => 'cursor',
		  )->Show;
		$lock_ok = 0;
	    } else {
		$lock_ok = 1;
	    }
	};
	warn $@ if $@;
    }
#warn "lockok=$lock_ok";
    $lock_ok;
}

sub unlock_file_temp {
#warn "file=? unlock: can_lock=$can_lock";
    return if (!$can_lock || !$options->{'lock'});
    eval q{
	use Fcntl qw(:flock);
#warn "try lock";
	flock CURRFILE, LOCK_UN;
    };
    warn $@ if $@;
    close CURRFILE;
#warn "cloce";
    $is_opened = 0;
}

sub insert_all {
    $top->Busy($Tk::VERSION >= 800.014 ? (-recurse => 1) : ());
    $project_frame->delete('all');
    foreach ($root->sorted_subprojects($options->{'sort'})) {
	insert_old_project($_);
    }
    if (defined $current_project) {
	$project_frame->selectionSet(make_path($current_project));
    }
    $top->Unbusy($Tk::VERSION >= 800.014 ? (-recurse => 1) : ());
}

sub insert_old_project {
    my($p) = @_;
    insert_project($p);
    if (!$options->{'onlytop'}) {
	foreach ($p->sorted_subprojects($options->{'sort'})) {
	    insert_old_project($_);
	}
    }
}

sub update_costs_option {
    my $interactive = shift;
    if ($options->{'hourlyrate'} > 0) {
	$has_costs = 1;
    } else {
	$has_costs = 0;
    }
    if ($interactive) {
	insert_all();
	my $costs_col = $pf_time_index+3;
	if ($interactive && !$has_costs) {
	    if ($project_frame->header('exist', $costs_col)) {
		$project_frame->header('delete', $costs_col);
	    }
	} else {
	    $project_frame->header
		('create', $costs_col,
		 -text => 'Cost (' . $options->{'hourlyrate'} . ' ' .
		 $options->{'currency'} . ')');
	}
    }
}

sub dump_data {
    print STDERR $root->dump_data();
    if (!open(OUT, ">/tmp/timex.data")) {
	$status_text->configure(-text => "Can't write to timex.data: $!");
	return;
    }
    print OUT $root->dump_data();
    close OUT;
}

sub old_save_file {
    eval { require Data::Dumper };
    if ($@) {
	$status_text->configure(-text => $@);
	return;
    }

    return if (!$options->{'file'});

    my $datafile = "$options->{'file'}.data";
    if ($^O =~ /(mswin|dos)/i) {
	$datafile =~ s/\.pj1//; # strip first extension
    }

    if (!open(OUT, ">$datafile")) {
	$status_text->configure
	  (-text => "Can't write to <$datafile>: $!");
	return;
    }
    my $dd = new Data::Dumper [$root], ['root'];
    eval { $dd->Purity(1)->Indent(1) }; # eval for versions before 2.081
    my $dump;
    eval { $dump = $dd->Dumpxs };
    if ($@) {
	$dump = $dd->Dump;
    }
    print OUT $dump, "\n";
    close OUT;
}

sub save_file {
    my($autosave) = @_;

    if (!$options->{'file'}) {
	if (!$autosave) {
	    return save_as_file(@_);
	} else {
	    return;
	}
    }

    if (defined $current_project) {
	$current_project->end_time;
    }

    if (!$autosave) {
	foreach (reverse(0 .. 8)) {
	    rename "$options->{'file'}.$_", "$options->{'file'}." . ($_+1);
	}
    }
    rename $options->{'file'}, "$options->{'file'}.0";

    unlock_file_temp() if $lock_is_strict;
    if (!$root->save("$options->{'file'}")) {
	$status_text->configure(-text => $@);
    } else {
	$status_text->configure(-text => "Saved <$options->{'file'}>");
    }
    old_save_file() if $options->{'securesave'};
    lock_file("$options->{'file'}") if $lock_is_strict;

    if (defined $current_project) {
	$current_project->unend_time;
    }

    if (!$autosave) {
	$root->modified(0);
    }

    lock_file($options->{'file'});

    set_autosave();
}

sub save_as_file {
    my $autosave = shift;

    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter project file',
			 -File => $file,
			 -Path => $path,
			 -FPat => '*.pj1',
			 -Create => 1);
    return unless $file;

    $file = adjust_filename($file);
    $options->{'file'} = $file;

    save_file($autosave);
}

sub sos_filename {
    my $file = shift;
    dirname($file) . "/#" . basename($file) . "#";
}

sub save_sos {
    return if !$root || !$root->modified;
    my $file;
    if (!$options->{'file'}) {
	$file = sos_filename("$home/tktimex.pj1");
    } else {
	$file = sos_filename($options->{'file'});
    }
    if (defined $current_project) {
	$current_project->end_time;
    }
    warn "Saving sos file $file...\n";
    $root->save($file);
    if (defined $current_project) {
	$current_project->unend_time;
    }

    eval {
	require Mail::Send;
	my $msg = Mail::Send->new;
	$msg->to((getpwuid($<))[0]);
	$msg->subject("tktimex: sos file");
	my $fh = $msg->open;
	print $fh <<EOF;
A copy of your tktimex data is saved in $file.
Please check whether the data is complete, then copy this file
as your tktimex data file with:

    @{[
         $os eq 'win' ? "copy" : "cp"
      ]} $file $options->{'file'}

EOF
        $fh->close;
    };
    warn $@ if $@;
}

sub _overwrite_warning {
    my $file = shift;
    if (-e $file) {
	require Tk::Dialog;
	die if ($top->Dialog
		(-title => 'Warning',
		 -text => "Really overwrite $file with skeleton data?\n".
		 "All time information will be lost in $file!",
		 -popover => 'cursor',
		 -default_button => 'No',
		 -buttons => ['Yes', 'No'])->Show ne 'Yes');
    }
}

sub save_skeleton {
    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter skeleton project file',
			 -Path => $path,
			 -FPat => '*.pj1',
			 -Create => 1);
    return unless $file;
    $file = adjust_filename($file);
    eval {
	_overwrite_warning($file);
    };
    return if ($@);

    $root->save($file, -skeleton => 1);
}

sub save_subproject {
    my $p = get_project_from_selection();
    return if !$p;
    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter project file',
			 -Path => $path,
			 -FPat => '*.pj1',
			 -Create => 1);
    return unless $file;
    $file = adjust_filename($file);
    eval {
	_overwrite_warning($file);
    };
    return if ($@);

    $p->save($file);
}

sub save_xml {
    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter XML project file',
			 -File => $file,
			 -Path => $path,
			 -FPat => '*.xml',
			 -Create => 1);
    return unless $file;
    
    $file = adjust_filename($file, ".xml");
    require Timex::Project::XML;
    my $clone = clone Timex::Project::XML $root;
    $clone->save($file);
}

sub merge_file {
    my $path;
    (undef, $path) = fileparse($options->{'file'});
    my $file = get_filename($top,
			    -Title => 'Enter project file for merge',
			    -Path => $path,
			    -FPat => '*.pj1',
			    -Create => 0);
    return unless $file;

    merge_file_noninteractive($file);
}

sub merge_file_noninteractive {
    my $file = shift;
    my $new_project = new Timex::Project;
    if (!$new_project->load($file)) {
	$status_text->configure(-text => $@);
	return;
    }
    my $diff = $root->merge($new_project);
    insert_all() if $diff;
    $status_text->configure
      (-text => "Merge completed with $diff difference" .
       ($diff == 1 ? "" : "s"));
}

sub get_filename {
    my($top, %args) = @_;
    my %change_opt;
    my $defaultextension;
    if ($args{'-FPat'}) {
	if ($Tk::VERSION <= 800.011) {
	    ($defaultextension = $args{'-FPat'}) =~ s/^\*\.//;
	} else {
	    ($defaultextension = $args{'-FPat'}) =~ s/^\*//;
	}
    }

    if ($args{-Create} && $top->can('getSaveFile')) {
	my $file = $top->getSaveFile
	  (-initialdir => $args{-Path},
	   -initialfile => $args{'File'},
	   -defaultextension => $defaultextension,
	   -title => $args{-Title},
	   ($Tk::VERSION >= 800.012 && $args{'-FPat'} =~ /pj1/ ?
	    (-filetypes => [['Timex files', '.pj1'],
			    ['All files',  '*']])
	    : ()),
	  );
	return $file;
    } elsif (!$args{-Create} && $top->can('getOpenFile')) {
	my $file = $top->getOpenFile
	  (-initialdir => $args{-Path},
	   -defaultextension => $defaultextension,
	   -title => $args{-Title},
	   ($Tk::VERSION >= 800.012 && $args{'-FPat'} =~ /pj1/ ?
	    (-filetypes => [['Timex files', '.pj1'],
			    ['Timex XML files', '.xml'], # XXX well...
			    ['All files',  '*']])
	    : ()
	   ),
	  );
	return $file;
    }

    my $filedialog = 'FileDialog';
    if ($os eq 'win') {
	$@ = "XXX Tk::FileDialog does not work with win32";
    } else {
	eval { require Tk::FileDialog };
    }
    if ($@) {
	warn "Harmless warning:\n$@\n";
	require Tk::FileSelect;
	$filedialog = 'FileSelect';
	%change_opt = (-FPat   => '-filter',
		       -Path   => '-directory',
		       -File   => undef,
		       -Create => undef,
		       -Title  => undef,
		      );
    }
    foreach (keys %args) {
	if (exists $change_opt{$_}) {
	    if (defined $change_opt{$_}) {
		$args{$change_opt{$_}} = delete $args{$_};
	    } else {
		delete $args{$_};
	    }
	}
    }
    my $fd = $top->$filedialog(%args);
    $fd->Show(-popover => 'cursor');
}

sub get_file_path {
    my($file, $path);
    if ($options->{'file'}) {
	($file, $path) = fileparse($options->{'file'});
    } else {
	$file = "";
	$path = $home || "/";
    }
    ($file, $path);
}

sub set_autosave {
    if ($options->{'autosave'}) {
	if (defined $autosave_after) {
	    $autosave_after->cancel;
	}
	$autosave_after = $top->after($options->{'update'}*1000,
				      sub { save_file(1) });
    }
}

sub toggle_autosave {
    set_autosave();
}

sub set_dateformat {
    insert_all();
    if (set_time_update()) {
	set_timeout();
    }
    foreach my $w ($top->Descendants("Toplevel")) {
	if ($w->{WindowType} and $w->{WindowType} eq 'Daily details' and
	    $w->{InvokeButton}) {
	    $w->{InvokeButton}->invoke;
	}
    }
}

sub not_running {
    my($var, $p) = @_;
    my $project_is_running;
    if (defined $p and defined $current_project and $p eq $current_project) {
	$project_is_running = 1;
    }
    if (!defined $p and defined $current_project) {
	$project_is_running = 1;
    }
    if ($project_is_running) {
	require Tk::Dialog;
	$top->Dialog(-title => 'Warning',
		     -text  =>
		     "Can't perform this action while project running",
		     -popover => 'cursor',
		    )->Show;
	if (defined $var) {
	    # alte Einstellung wiederherstellen
	    $$var = ($$var ? 0 : 1);
	}
	return undef;
    } else {
	return 1;
    }
}

sub toggle_show_archived {
    if (not_running(\$options->{'archived'})) {
	insert_all();
    }
}

sub toggle_show_only_top {
    not_running(\$options->{'onlytop'}) && insert_all();
}

sub toggle_time_arbeitstag {
    insert_all();
}

sub show_attributes {
    my($path, $readonly) = @_;

    if (defined $current_project) { $readonly = 1 }

    if (!defined $path) {
	$path = get_sel_entry();
	return if !defined $path;
    }

    my $project = $project_frame->info('data', $path);
    return if !defined $project;

    my $attribute_top = $top->Toplevel(-title => "Attributes");
    my $f = $attribute_top->Frame->pack(-fill => 'both', -expand => 1);
    my $row = 0;
    $f->Label(-text => 'Name: ')->grid(-row => $row, -column => 0,
				       -sticky => 'w');
    my $label = $project->label;
    my $name_entry = $f->Entry(-bg => $inner_bg,
			       -fg => $inner_fg,
			       -textvariable => \$label
			      )->grid(-row => $row, -column => 1,
				      -sticky => 'w');
    $name_entry->focus;
    if ($readonly) { $name_entry->configure(-state => 'disabled') }

    if ($project->parent) {
	$row++;
	$f->Label(-text => 'Parent:')->grid(-row => $row,
					    -column => 0,
					    -sticky => 'w');
	$f->Label(-text => ($project->parent eq $root ?
			    '(Root)' : $project->parent->label)
		 )->grid(-row => $row, -column => 1,
			 -sticky => 'w');
    }

    my $new_parent;
    my($combo, %combo_args);
  TRYCOMBO: {
	eval {
	    die "Don't use ComboBox";
	    require ComboBox; # XXX Tk::
	    $combo = 'ComboBox';
	    %combo_args = (-caseless => 'on', # XXX
			   -match => 'on');
	};
	last TRYCOMBO if (defined $combo);
	require Tk::BrowseEntry;
	$combo = 'BrowseEntry';
    }
    $row++;
    my $browse = $f->$combo(-label => "New Parent",
			    -variable => \$new_parent,
			    -bg => $inner_bg,
			    -fg => $inner_fg,
			    %combo_args);
    if ($readonly) {
	$browse->configure(-state => 'disabled')
    }
    # Verwendung des Schwartzian Transform wegen Problemen mit lc.
    # Es ist vielleich auch marginal schneller.
    my(@all_labels) =
	map { $_->[1] }
        sort { $a->[0] cmp $b->[0] }
        map { [lc($_), $_] }
        $root->all_pathnames;
    foreach (@all_labels) {
	$_ = '(Root)' if !defined $_ || $_ eq '';
	$browse->insert("end", $_);
    }
    $browse->grid(-row => $row, -column => 0,
		  -columnspan => 3, -sticky => 'w');

    my $archived = $project->{'archived'};
    $row++;
    my $arch_check = $f->Checkbutton
      (-text => 'Archived',
       -variable => \$archived
      )->grid(-row => $row, -column => 0, -sticky => 'w');
    if ($readonly) { $arch_check->configure(-state => 'disabled') }

    my $rcsfile = $project->rcsfile;
    $row++;
    $f->Label(-text => 'RCS/CVS file:'
	     )->grid(-row => $row, -column => 0, -sticky => 'w');
    $f->Entry(-bg => $inner_bg,
	      -fg => $inner_fg,
	      -textvariable => \$rcsfile
	     )->grid(-row => $row, -column => 1, -sticky => 'w');
    $f->Button
      (-text => 'Browse...',
       -command => sub {
	   my($file, $path) = fileparse($rcsfile) if $rcsfile;
	   my $newfile = get_filename($attribute_top,
				      -Title  => 'RCS/CVS file',
				      ($rcsfile ? (-File   => $file,
						   -Path   => $path) : ()),
				      -Create => 0,
				     );
	   if ($newfile) {
	       $rcsfile = $newfile;

	   }
       })->grid(-row => $row, -column => 2, -sticky => 'w');

    $row++;
    my $ff = $f->Frame->grid(-row => $row, -column => 0,
			     -columnspan => 3, -sticky => "w");
    $ff->Button(-text => 'Show intervals',
		-command => sub {
		    show_intervals($f,
				   $project,
				  -readonly => $readonly);
		})->pack(-side => "left");
    my $note_label = "Note";
    if ($project->has_note) {
	$note_label .= " *";
    }
    $ff->Button(-text => $note_label,
		-command => sub {
		    show_note($top);
		})->pack(-side => "left");

    my $command_frame = $attribute_top->Frame->pack(-fill => 'x',
						    -expand => 1);
    my $ok = $command_frame->Button
      (-command => sub {
	   my $insert_all;
	   if ($label && $label ne $project->label) {
	       $project->label($label);
	       $insert_all++;
	   }
	   if (defined $new_parent && grep($_ eq $new_parent, @all_labels)) {
	       my $new_parent_p;
	       if ($new_parent eq '(Root)') {
		   $new_parent_p = $root;
	       } else {
		   $new_parent_p = $root->find_by_pathname($new_parent);
	       }
	       if ($new_parent_p) {
		   if ($project->reparent($new_parent_p)) {
		       $insert_all++;
		   } else {
		       require Tk::Dialog;
		       $attribute_top->Dialog
			 (-title => 'Warning',
			  -text  =>
			  "Can't reparent " . $project->label . " to " .
			  $new_parent_p->label,
			  -popover => 'cursor',
			 )->Show;
		   }
	       }
	   }
	   $insert_all++ if ($archived && !$project->{'archived'});
	   $project->archived($archived);
	   $project->rcsfile($rcsfile);
	   $attribute_top->destroy();
	   insert_all() if $insert_all;
       }
      );
    set_text_or_image($ok, "yes.gif", "OK");
    $ok->pack(-side => 'left');
    if ($readonly) { $ok->focus }
    my $cancel = $command_frame->Button
      (-command => sub { $attribute_top->destroy() }
      );
    $attribute_top->bind('<Escape>' => sub { $cancel->invoke });
    set_text_or_image($cancel, "no.gif", "Cancel");
    $cancel->pack(-side => 'left');
    $attribute_top->Popup(-popover => 'cursor');
}

BEGIN { state_change("parsed 74%"); }

sub show_intervals {
    my($top, $project, %args) = @_;

    my $readonly      = $args{-readonly};
    my $show_seconds  = $args{-show_seconds};
    my $group         = $args{-group} || '';
    my $geometry      = $args{-geometry};
    my $modified      = $args{-modified};
    my $day           = $args{-day};
    my $subproj       = $args{-subproj};

    if (!defined $project) {
	$project = entry_to_project(get_sel_entry());
	return if !defined $project;
    }

    if ($group eq 'weekly') {
	eval {
	    require Date::Calc;
	};
	if ($@) {
	    warn "$@. Reverting to daily";
	    $group = "daily";
	}
    }

    #$top->Busy($Tk::VERSION >= 800.014 ? (-recurse => 1) : ());

    my @rev;
    if ($project->rcsfile) {
	$top->Busy($Tk::VERSION >= 800.014 ? (-recurse => 1) : ());
	eval {
	    my $rcs = get_rcs_from_cache($project);
	    if ($rcs) {
		foreach my $rev ($rcs->revisions) {
		    push(@rev, [$rev->revision,
				$rev->unixtime,
				$rcs->symbolic_name($rev)]);
		}
	    } else {
		die "Can't create rcs/cvs object";
	    }
	};
	warn $@ if $@;
	$top->Unbusy($Tk::VERSION >= 800.014 ? (-recurse => 1) : ());
    }

    my($w, $lb, $real_lb, $times);

    my $update = sub {
	my $t = shift;
	$t->destroy if $t;
	$args{-geometry}     = $w->geometry;
	$args{-show_seconds} = $show_seconds;
	$args{-group}        = $group;
	$args{-modified}     = $modified;
	$args{-subproj}      = $subproj;
	$w->destroy;
	show_intervals($top, $project,
		       %args);
    };

    my $log_viewer = sub {
	my $i = shift;
	if ($project->rcsfile) {
	    eval {
		my $rcs = get_rcs_from_cache($project);
		if ($rcs) {
		    my $log_entries = $rcs->get_log_entries
			(@{$times->[$i]}[0..1]);
		    my $t = $w->Toplevel
			(-title => "Log entries for "
			 . $project->pathname . " "
			 . join(" - ", map { scalar localtime $_ } 
				       @{$times->[$i]}[0..1]));
		    my $ok = $t->Button(-text => 'OK',
					-command => sub {
					    $t->destroy;
					})->pack(-side => "bottom");
		    $t->bind('<Escape>' => sub { $ok->invoke });
		    require Tk::ROText;
		    my $ro = $t->Scrolled
			("ROText", -scrollbars => "so$sbside",
			 -wrap => "none",
			 )->pack(-fill => "both", -expand => 1);
		    $ro->insert("end", $log_entries);
		    $ok->focus;
		}
	    }
	}
    };

    my $interval_editor = sub {
	my $i = shift;
	return if $readonly;
	my $has_date;
	my($inner_bg_opt, $inner_fg_opt) = ('-bg', '-fg');
	eval {
	    require Tk::Date;
	    $has_date = 1 if !$@;
	    if ($Tk::Date::VERSION >= 0.30) {
		($inner_bg_opt, $inner_fg_opt) = ('-innerbg', '-innerfg');
	    }
	};
	my $t = $w->Toplevel(-title => "Edit line $i for "
			               . $project->pathname);
	my($from, $to) = @{$times->[$i]};
	$t->Label(-text => 'From:')->grid(-row => 0, -column => 0);
	my $from_date = ($has_date
			 ? $t->Date($inner_bg_opt => $inner_bg,
				    $inner_fg_opt => $inner_fg,
				    -variable => \$from,
				    -choices => 'now',
				    )
			 : $t->Entry(-bg => $inner_bg,
				     -fg => $inner_fg,
				     -textvariable => \$from)
			 );
	$from_date->grid(-row => 0, -column => 1);
	$t->Label(-text => 'To:')->grid(-row => 1, -column => 0);
	my $to_date = ($has_date
		       ? $t->Date($inner_bg_opt => $inner_bg,
				  $inner_fg_opt => $inner_fg,
				  -variable => \$to,
				  -choices => 'now',
				  )
		       : $t->Entry(-bg => $inner_bg,
				   -fg => $inner_fg,
				   -textvariable => \$to)
		       );
	$to_date->grid(-row => 1, -column => 1);
	my $f = $t->Frame->grid(-row => 2, -column => 0, -columnspan => 2);

	my $okb = $f->Button
	  (-text => 'OK',
	   -command => sub {
	       $project->set_times($i, $from, $to);
	       $update->($t);
	   },
	  )->pack(-side => 'left');
	my $cancelb = $f->Button
	  (-text => 'Cancel',
	   -command => sub {
	       $t->destroy;
	   },
	  )->pack(-side => 'left');
	$cancelb->focus;
	my $deleteb = $f->Button
	  (-text => 'Delete',
	   -command => sub {
	       $project->delete_times($i);
	       $update->($t);
	   },
	  )->pack(-side => 'left');
	$t->bind('<Return>' => sub { $okb->invoke });
	$t->bind('<Escape>' => sub { $cancelb->invoke });
	$t->Popup(-popover => 'cursor');
    };

    my $double_click = sub {
	my $i = shift;

	my $e = $real_lb->XEvent;
	my $x = $e->x;
	my $col_width = 0;
	my $lb_column;
	foreach my $lb_i (0 .. $lb->cget(-columns)-1) {
	    my $old_col_width = $col_width;
	    $col_width += $lb->columnWidth($lb_i);
	    if ($x >= $old_col_width and $x <= $col_width) {
		$lb_column = $lb_i;
		last;
	    }
	}

	if ($group eq '' && !$subproj &&
	    (!defined $lb_column || $lb_column < 3)) {
	    $interval_editor->($i);
	} else {
	    $log_viewer->($i);
	}
    };

    $w = $top->Toplevel(-title => "Intervals for " . $project->pathname);
    my $no_cols = 2;
    my $rev_lifetime_col;
    $no_cols ++   if !$group; # zusätzliche To-Spalte
    $no_cols ++   if $show_seconds; # für From/Date-Spalte
    $no_cols ++   if $show_seconds and !$group; # für To-Spalte
    $no_cols += 2 if @rev;
    $lb = $w->Scrolled('HList', -scrollbars => "oso$sbside",
		       -bg => $inner_bg,
		       -fg => $inner_fg,
		       -columns => $no_cols,
		       -width => 80,
		       -header => 1,
		       -command => $double_click,
		      )->pack(-fill => 'both', -expand => 1);
    $real_lb = $lb->Subwidget("scrolled");
    {
	my $col = 0;
	if ($group eq 'daily') {
	    $lb->header('create', $col++, -text => 'Day');
	} elsif ($group eq 'weekly') {
	    $lb->header('create', $col++, -text => 'Week');
	} elsif ($group eq 'monthly') {
	    $lb->header('create', $col++, -text => 'Month');
	} else {
	    $lb->header('create', $col++, -text => 'From');
	}
	$lb->header('create', $col++, -text => 'seconds')
	  if $show_seconds;
	if (!$group) {
	    $lb->header('create', $col++, -text => 'To');
	    $lb->header('create', $col++, -text => 'seconds')
	      if $show_seconds;
	}
	$lb->header('create', $col++, -text => 'Time');
	if (@rev) {
	    $lb->header('create', $col++, -text => 'RCS/CVS');
	    $rev_lifetime_col = $col++;
	    $lb->header('create', $rev_lifetime_col,
			-text => 'Version lifetime');
	}
    }

    my $anchor_set = 0;
    my $last_rev_def;
    my $i = 0;
    $times = $project->interval_times($group,
				      -recursive => $subproj,
				      -asref => 1,
				     );

    foreach (@$times) {
	my($from, $to, $interval) = @$_;

	my(@fromdate) = localtime($from);
	$fromdate[4]++;
	$fromdate[5]+=1900;

	my $fromdate;
	if ($group eq '') {
	    $fromdate = sprintf "%02d.%02d.%04d %02d:%02d:%02d",
	                        @fromdate[3,4,5,2,1,0];
	} elsif ($group eq 'daily') {
	    $fromdate = sprintf "%02d.%02d.%04d", @fromdate[3,4,5];
	} elsif ($group eq 'weekly') {
	    my $wk = Date::Calc::Week_Number(@fromdate[5,4,3]);
	    $fromdate = sprintf "%02d/%04d", $wk, $fromdate[5];
	} elsif ($group eq 'monthly') {
	    $fromdate = sprintf "%02d.%04d", @fromdate[4,5];
	} elsif ($group eq 'yearly') {
	    $fromdate = sprintf "%04d", $fromdate[5];
	}

	$lb->add($i, -text => $fromdate);
	my $col = 1;
	$lb->itemCreate($i, $col++, -text => $from)
	  if $show_seconds;

	if (!$anchor_set and defined $day and $day <= $from) {
	    $lb->anchorSet($i);
	    $anchor_set = 1;
	}

	my(@todate, $todate);
	if (defined $to) {
	    @todate = localtime($to);
	    $todate[4]++;
	    $todate[5]+=1900;
	    $todate = sprintf
	      "%02d.%02d.%04d %02d:%02d:%02d", @todate[3,4,5,2,1,0];
	    if (!$group) {
		$lb->itemCreate($i, $col++, -text => $todate);
		$lb->itemCreate($i, $col++, -text => $to)
		  if $show_seconds;
	    }
	    $interval = $to-$from if !$group;
	    $lb->itemCreate($i, $col++, -text => sec2time($interval, 'h', 0));
	    my @t;
	    foreach my $rev (@rev) {
		if ($rev->[1] >= $from and $rev->[1] <= $to) {
		    my $t = $rev->[0];
		    if ($rev->[2]) { $t .= " (" . $rev->[2] . ")" }
		    push(@t, $t);
		    if (exists $last_rev_def->{'Time'}) {
			$lb->itemCreate
			  ($last_rev_def->{'Item'},
			   $rev_lifetime_col,
			   -text => sec2time($from-$last_rev_def->{'Time'},
					     'dd', 0));
		    }
		    $last_rev_def = {Time => $to, Item => $i};
		}
	    }
	    if (@t) { $lb->itemCreate($i, $col++, -text => join(", ", @t)) }
	} else {
	    $lb->itemCreate($i, $col++, -text => 'Running');
	}
	$i++;
    }

    #$top->Unbusy($Tk::VERSION >= 800.014 ? (-recurse => 1) : ());

    if (exists $last_rev_def->{'Time'}) {
	$lb->itemCreate
	  ($last_rev_def->{'Item'}, $rev_lifetime_col,
	   -text => sec2time(time-$last_rev_def->{'Time'}, 'dd', 0));
    }

    $w->withdraw;
    $lb->see($i-1) if $i > 1;
    my $f = $w->Frame->pack(-fill => 'x');
    my $close_sub = sub {
	insert_all() if $modified;
	$w->destroy;
    };
    $w->protocol('WM_DELETE_WINDOW', $close_sub);
    my $clb = $f->Button(-text => 'Close',
			 -command => $close_sub,
			)->pack(-side => 'left');
    $f->Label(-text => '  ')->pack(-side => 'left');
    if ($group eq '' && !$subproj) {
	$f->Button(-text => 'Del',
		   -command => sub {
		       $project->delete_times($lb->info('selection'));
		       $modified++;
		       $update->();
		   }
		   )->pack(-side => 'left');
	$f->Button(-text => 'Ins',
		   -command => sub {
		       my @sel = $lb->info('selection');
		       my $before = (!@sel ? -1 : $sel[$#sel]);
		       $project->insert_times_after($before,
						    time, time);
		       $modified++;
		       $interval_editor->($before+1);
		       #$update->();
		   }
		   )->pack(-side => 'left');
    }
    if (!$subproj) {
	$f->Button(-text => 'Re-Sort',
		   -command => sub {
		       $project->sort_times;
		       # $modified++ nicht notwendig, weil sich nichts an der
		       # Gesamtzeit ändert
		       $update->();
		   }
		  )->pack(-side => 'left');
    }
    if ($group eq '' && !$subproj) {
	$f->Label(-text => ' ')->pack(-side => 'left');
	$f->Checkbutton(-text => 'Seconds',
			-variable => \$show_seconds,
			-command => sub { $update->() },
			)->pack(-side => 'left');
    }
    $f->Label(-text => ' ')->pack(-side => 'left');
    $f->Checkbutton(-text => 'Subprojects',
		    -variable => \$subproj,
		    -command => sub { $update->() },
		   )->pack(-side => 'left');

    require Tk::Optionmenu;
    $f->Label(-text => ' Group:')->pack(-side => 'left');
    $f->Optionmenu(-variable => \$group,
		   -options => ['', qw/daily weekly monthly yearly/],
		   -command => sub { $update->() },
		   )->pack(-side => "left");

    $clb->focus;
    $w->bind('<Escape>' => sub { $clb->invoke });

    my @popup_args;
    #push @popup_args, (-popover => 'cursor') unless $geometry;
    $w->Popup; #(@popup_args);
    if ($geometry) {
	$w->geometry($geometry);
    }
}

sub show_note {
    my($top, $project, %args) = @_;

    if (!defined $project) {
	$project = entry_to_project(get_sel_entry());
	return if !defined $project;
    }

    my $t = $top->Toplevel(-title => 'Note for ' . $project->pathname);
    my $txt = $t->Scrolled('Text', -scrollbars => "so$sbside"
			  )->pack(-fill => 'both', -expand => 1);
    $txt->focus;
    if ($project->has_note) {
	foreach ($project->note) {
	    $txt->insert('end', $_ . "\n");
	}
    }
    my $f = $t->Frame->pack(-fill => 'x', -expand => 1);
    $f->Button(-text => 'OK',
	       -command => sub {
		   my $s = $txt->get('1.0', 'end');
		   $project->set_note(split(/\n/, $s));
		   $t->destroy;
	       })->pack(-side => 'left');
    my $cancel = $f->Button(-text => 'Cancel',
	       -command => sub { $t->destroy })->pack(-side => 'left');
    $t->bind('<Escape>' => sub { $cancel->invoke });
    $t->Popup(-popover => 'cursor');
}

sub set_time_update {
    my $old_time_update = $time_update;
    $time_update = ($options->{'dateformat'} eq 'hs' ? 1 : 60);
    $time_update < $old_time_update;
}

sub set_text_or_image {
    my($widget, $image, $text) = @_;
    # use image if available, otherwise text
    if (-r $image) {
	eval { $widget->configure
		 (-image => $widget->Photo(-file => Tk::findINC($image)))
	     };
	if (!$@) { return }
    }
    $widget->configure(-text => $text);
}

sub make_path {
    my($p) = @_;
    return if !$p;
    die "wrong arg for make_path: <$p>" if !$p->isa('Timex::Project');
    my @path = $p->path;
    join($separator, @path[1 .. $#path]);
}

sub get_entry {
    my($w) = @_;
    my $Ev = $w->XEvent;
    $w->GetNearest($Ev->y);
}

sub get_sel_entry {
    my $path = $project_frame->info('anchor');
    return $path if defined $path;
    $project_frame->info('selection');
}

sub entry_to_project {
    my($path) = @_;
    return if !defined $path;
    $project_frame->info('data', $path);
}

sub quit_program {
    require Tk::Dialog;
    if ($root->modified || defined $current_project) {
	if (!defined $quit_dialog) {
	    $quit_dialog = $top->Dialog(-title => 'Quit Program',
					-text  => "Really quit?\n" .
					($root->modified ?
					 "(modified data) " : "") .
					(defined $current_project ?
					 "(project running) " : ""),
					-default_button => 'No',
					-buttons => ['Yes', 'No'],
					-popover => 'cursor',
				       );
	}
	return 0 if $quit_dialog->Show ne 'Yes';
    }
    $top->destroy;
}

sub sec2time {
    my($sec, $dateformat, $day8) = @_;
    $dateformat = $options->{'dateformat'} unless defined $dateformat;
    $day8       = $options->{'day8'}       unless defined $day8;
    my($day, $hour, $min);
    if ($dateformat =~ /^d/) {
	$day = int($sec / ($day8 ? 28800 : 86400));
	$sec = $sec % ($day8 ? 28800 : 86400);
    } elsif ($dateformat eq 'frac d') {
	$day = $sec / ($day8 ? 28800 : 86400);
    }
    if ($dateformat eq 'frac h') {
	$hour = $sec / 3600;
    } else {
	$hour = int($sec / 3600);
	$sec  = $sec % 3600;
	$min  = int($sec / 60);
    }
    if ($dateformat eq 'd') {
	sprintf("%3dd %02d:%02d", $day, $hour, $min);
    } elsif ($dateformat eq 'h') {
	sprintf("%3d:%02d", $hour, $min);
    } elsif ($dateformat eq 'dd') { # round working days
	sprintf("%3dd", $day + ($hour >= ($day8 ? 4 : 12) ? 1 : 0));
    } elsif ($dateformat eq 'frac d') {
	sprintf("%.2fd", $day);
    } elsif ($dateformat eq 'frac h') {
	sprintf("%.2fh", $hour);
    } else {
	sprintf("%02d:%02d:%02d", $hour, $min, $sec % 60);
    }
}

sub check_still_today {
    my @new_nowtime = localtime;
    my $new_today_time =
      time - $new_nowtime[0] - $new_nowtime[1]*60 - $new_nowtime[2]*60*60;
    if ($new_today_time != $today_time) {
	$today_time = $new_today_time;
	@nowtime = @new_nowtime;
	insert_all();
    }
}

# force appending extension (default: .pj1) to filename
sub adjust_filename {
    my($file, $ext) = @_;
    $ext = ".pj1" unless defined $ext;
    (my $ext_re = $ext) =~ s/\./\\./g; # quote dots for regex
    if ($file !~ /$ext_re$/) {
	$file = "$file$ext";
    }
    $file;
}


sub create_menu_last_projects {
    # find last separator
    my $end = $mb_file_menu->index('end');
    my $i = $end;
  LOOP: {
	while ($i >= 0) {
	    last LOOP if ($mb_file_menu->type($i) eq 'separator');
	    $i--;
	}
	$status_text->configure("Separator in Menu File not found");
	return;
    }
    # delete anything from the item after the separator to the end
    if ($i < $end) {
	$mb_file_menu->delete($i+1, 'end');
    }
    # insert last_projects
    $i = 0;
    foreach my $p (@$last_projects) {
	my $pathname = $p->pathname;
	$i++;
	$mb_file_menu->command(-label => "$i: " . $pathname,
			       -underline => 0,
			       -command => sub {
				   start_stop($p);
			       });
    }
}

sub add_last_projects {
    my($project) = @_;
    my $i;
    for($i = 0; $i <= $#$last_projects; $i++) {
	if ($last_projects->[$i] eq $project) {
	    splice @$last_projects, $i, 1;
	    last;
	}
    }
    unshift(@$last_projects, $project);
    if (@$last_projects > $max_last_projects) {
	$#$last_projects = $max_last_projects-1; # $max_last_projects Dateien merken
    }
}

# XXX bei KDE gibt es das Problem, daß beim ersten Minimize
# das Fenster nach +0+0 springt ... fvwm2 hat damit keine Probleme (?)
sub minmaximze {
    $minimized = !$minimized;
    if ($minimized) {
	$min_button->configure(-image => $down_photo);
	$balloon->attach($min_button, -msg => 'Maximize')
	  if $balloon;
	$save_geometry = $top->Width . "x" . $top->Height;
	my $menu_height = $top->Height
	  - $project_frame->Height - $status_frame->Height;
	$top->geometry($top->Width . "x" . $menu_height);
    } else {
	$min_button->configure(-image => $up_photo);
	$balloon->attach($min_button, -msg => 'Minimize')
	  if $balloon;
	$top->geometry($save_geometry);
	$top->raise;
    }
}

sub accept_drop {
    my($c, $seln) = @_;
    my $filename;
    my $own =  $c->SelectionExists('-selection'=>$seln);
    my @targ = $c->SelectionGet('-selection'=>$seln,'TARGETS');
    foreach (@targ) {
	if (/FILE_NAME/) {
	    $filename = $c->SelectionGet('-selection'=>$seln,'FILE_NAME');
	    last;
	}
	if ($os eq 'win' && /STRING/) {
	    $filename = $c->SelectionGet('-selection'=>$seln,$_);
	    last;
	} 
    }
    if (defined $filename) {
	$c->after(10, sub {load_merge_popup($filename)});
    }
}

sub load_merge_popup {
    my $filename = shift;
    my $load_menu = $top->Menu(-tearoff => 0);
    $load_menu->command(-label => "Merge",
			-command => sub {
			    merge_file_noninteractive($filename);
			});
    $load_menu->command(-label => "Load",
			-command => sub {
			    load_file_noninteractive($filename);
			});
    $load_menu->command(-label => "Cancel",
			-command => sub { });
    $load_menu->Popup(-popover => 'cursor');
}

sub get_home_dir {
    if (!defined $home) {
	if ($^O eq 'MSWin32') {
	    eval q{
		use Win32Util;
		$home = Win32Util::get_user_folder();
	    };
	} else {
	    $home = eval { local $SIG{__DIE__};
			   (getpwuid($<))[7];
		       };
	}
	if (!defined $home) {
	    $home = $ENV{'HOME'} || '/';
	}
    }
    $home;
}

# This is a hack using xwininfo to report if another tktimex window
# is already running. This must be called before $top is created...
sub tktimex_running {
    return 0 if ($os eq 'win');
    open(WININFO, "xwininfo -tree -root |");
    my $r = 0;
    while (<WININFO>) {
	if (/^\s*0x[0-9a-fA-F]+\s+"tktimex.*":\s+\("tktimex"\s+"Tktimex"\)/) {
	    $r = 1;
	    last;
	}
    }
    close WININFO;
    return $r;
}

sub get_rcs_from_cache {
    my $project = shift;
    my $rcs;
    if ($rcs_cache{$project->rcsfile}) {
	$rcs = $rcs_cache{$project->rcsfile};
    } else {
	require Timex::Rcs;
	$rcs = new Timex::Rcs $project->rcsfile;
	$rcs_cache{$project->rcsfile} = $rcs;
    }
    $rcs;
}

sub show_about {
    my $dia = $top->Toplevel(-title => 'Copyright');
    $dia->Label(-text  => <<'EOF',

tktimex by Slaven Rezic (eserte@cs.tu-berlin.de)

Copyright (c) 1996-2000 Slaven Rezic. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software
   must display the following acknowledgement:
   This product includes software developed by Slaven Rezic.
4. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
		-justify => 'left')->pack;
    my $okb = $dia->Button(-text => 'OK',
			   -command => sub { $dia->destroy })->pack;
    $okb->focus;
    $dia->bind('<Escape>' => sub { $okb->invoke });
    $dia->Popup(-popover => 'cursor');
}

=head1 NAME

tktimex - project time manager

=head1 SYNOPSIS

    tktimex [options] [projectfile]

=head1 DESCRIPTION

B<tktimex> is a project time manager. Its purpose is to record working
times for projects. Projects may be grouped hierarchically with
subprojects. It is also possible to get some statistics.

=head2 QUICK OVERVIEW

To create a new project, select from the B<Project> menu the item
B<New>.

To start the timer on a particular project, select the project from
the list by mouse click and click on the B<Cont> button. To stop the
timer, click on the B<Pause> button.

If autosaving is on, after each click on B<Pause>, the project list
will be updated on disk, and so will every 10 minutes. If autosaving
is off, you have to manually save the project list by clicking on the
B<Save> button.

To reload an project list file, you have to specify the file name on
the command line:

	tktimex projectfile.pj1

If Tk::Getopt is installed on your system, you can set the default
project list file in the B<Option editor> (menu B<Options>).

=head1 COMMAND LINE OPTIONS

Possible options are:

	--file
	--[no]lock       (default: 1)
  	--[no]one-instance
  	--[no]as, --[no]autosave         (default: 1)
  	--update         (default: 600)
  	--[no]oneday-immediately         (default: 1)
  	--geometry       (default: 500x230)
  	--[no]securesave
  	--df, --dateformat       (default: h)
  	--[no]day8
  	--[no]archived
  	--[no]onlytop
  	--sort
  	--[no]busyind
  	--autoscroll     (default: none)
  	--hourlyrate
  	--currency       (default: DEM)

=head1 TODO

  - better Pod
  - View by day, by project, by interval, by month, by special attrib

=head1 BUGS

If tktimex crashes (it should only due to perl/Tk or OS problems!),
then it is possible that the project file gets corrupted. To prevent
loss of data, there are always some backup files with the suffixes .1,
.2 etc.

The -oneday-immediately option is not supported with Tk::DateEntry.

The tktimex process is very memory-consuming. Expect that 10 MB of the
virtual memory will be eaten.

Setting dateformat to "hs" (show hours, minutes and seconds) is not
recommended due to cpu waste. Better leave the option at "d" or "h".

=head1 FILES

    ~/.tktimexrc        personal configuration file
    ~/.tktimex.last     list of last accessed projects
    *.pj1               project files

=head1 SEE ALSO

perl(1), Tk(3), rcsintro(1), cvs(1), Timex::Project(3)

=head1 AUTHOR

Slaven Rezic (eserte@cs.tu-berlin.de)

Copyright (c) 1996-2000 Slaven Rezic. All rights reserved.

For a complete copyright see the Help/About menu entry.

=cut
