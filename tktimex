#!/usr/local/bin/perl 
# -*- perl -*-

#
# $Id: tktimex,v 2.6 1997/04/24 14:25:58 eserte Exp $
# Author: Slaven Rezic
# Mail: <URL:mailto:eserte@cs.tu-berlin.de>
# WWW:  <URL:http://www.cs.tu-berlin.de/~eserte/>
# Talk: <URL:telnet://ole.cs.tu-berlin.de:1211>
#

package main;

use Tk;
use Tk::ROText;
use Tk::BrowseEntry;
use FindBin;
use lib "$FindBin::Bin";
use Project;
use strict;

my $root = new Project;

my $quit_dialog;
my $copyright = 'tktimex © 1996 Slaven Rezic';
my $datafile = '/home/e/eserte/private/log/mytimex.pj1';
#my $datafile = "/tmp/mytimex.pj1"; # XXX
my $current_project_index = undef;
my $start_session_time = time;
my $time_after;
my $dateformat = 'h'; # XXX erst wenn ich sicher bin: 'd';
my $time_update;
&set_time_update();
my $autosave_after;
my $autosave_update = 60*20;
my $autosave = 1;
my @nowtime = localtime;
my $today_time = time - $nowtime[0] - $nowtime[1]*60 - $nowtime[2]*60*60;
my @projects_in_text;
my %projects_in_text;
my $project_status = "Left: Start/Stop | Middle: Attributes | Right: Create Subproject";
my $show_archived = 0;
my $show_only_top = 0;
my $time_arbeitstag = 0;

my $xgeometry;

my $i;
for ($i = 0; $i <= $#ARGV; ++$i) {
    $_ = $ARGV[$i];
  ARGL: {
	/^-geometry$/ && do { $xgeometry 
				= &get_arg(\$i, \@ARGV, "-geometry", "$_");
			      last ARGL; };
	/^-file$/ && do { $datafile 
			    = &get_arg(*i, *ARGV, "-file", "$_");
			  last ARGL; };
#	/^-switch$/ && do { $switch = 0; last ARGL; };
	/^-/ && do { &usage("bad argument: $_"); last ARGL; };
    }
}

my $top = new MainWindow;
$top->protocol('WM_DELETE_WINDOW', \&quit_program);
$top->title('tktimex');
$top->geometry($xgeometry) if $xgeometry;

my $menu_frame = $top->Frame(-relief => 'raised',
			     -borderwidth => 2);

my $mb_file = $menu_frame->Menubutton(-text => 'File')->pack(-side => 'left');
$mb_file->command(-label => 'Load',
		  -command => \&load_file);
$mb_file->command(-label => 'Save',
		  -command => \&save_file);
$mb_file->command(-label => 'Dump',
		  -command => \&dump_data);
$mb_file->command(-label => 'Quit',
		  -command => \&quit_program);

my $mb_project = $menu_frame->Menubutton(-text => 'Project'
					)->pack(-side => 'left');
$mb_project->command(-label => 'New',
		     -command => \&new_project);
$mb_project->command(-label => 'Pause',
		     -command => \&pause);

my $mb_options = $menu_frame->Menubutton(-text => 'Options'
					)->pack(-side => 'left');
$mb_options->checkbutton(-label => 'Autosave',
			 -command => \&toggle_autosave,
			 -variable => \$autosave);
$mb_options->checkbutton(-label => 'Dateformat H:M:S',
			 -command => \&toggle_dateformat,
			 -onvalue => 'd',
			 -offvalue => 'h',
			 -variable => \$dateformat);
$mb_options->checkbutton(-label => 'day = 8h',
			 -command => \&toggle_time_arbeitstag,
			 -variable => \$time_arbeitstag);
$mb_options->checkbutton(-label => 'Show archived',
			 -command => \&toggle_show_archived,
			 -variable => \$show_archived);
$mb_options->checkbutton(-label => 'Show only top',
			 -command => \&toggle_show_only_top,
			 -variable => \$show_only_top);

# XXX RO machen!
$menu_frame->Checkbutton(-text => '*',
			 -variable => \$root->{'modified'}
			)->pack(-side => 'right');

$menu_frame->Button(-text => 'Pause',
		    -command => \&pause)->pack(-side => 'right');
$menu_frame->Button(-text => 'Save',
		    -command => \&save_file)->pack(-side => 'right');

$menu_frame->pack(-expand => 1, -fill => 'x');

my $project_frame = $top->Frame;
$project_frame->pack(-expand => 1, -fill => 'both');
my $header_text = $project_frame->Text(-tabs => ['4c', '6.5c', '9c'],
				       -width => 63,
				       -height => 2,
				       -cursor => 'left_ptr',
				       -relief => 'ridge');
$header_text->pack(-expand => 1, -fill => 'x');
$header_text->insert('1.0', "\t\t  Time\nProjects:\t  Session\t  Today\t  All");
$header_text->bindtags(qw(dummy));

my $projects_scrollbar = $project_frame->Scrollbar(-orient => 'vertical');
$projects_scrollbar->pack(-side => 'right', -fill => 'y');
my $projects_text = $project_frame->Text
  (-yscrollcommand => [$projects_scrollbar => 'set'],
   -tabs => ['4c', '6.5c', '9c'],
   -width => 63,
   -height => 10,
   -spacing1 => 1,
   -spacing3 => 1,
   -cursor => 'left_ptr',
   -relief => 'ridge');
$projects_scrollbar->configure(-command => [$projects_text => 'yview']);
$projects_text->pack(-expand => 1, -fill => 'both');
$projects_text->bindtags(qw(dummy));
$projects_text->tagConfigure('running',
			     -relief => 'raised',
			     -borderwidth => 1,
			     -background  => 'SeaGreen3');
$projects_text->tagConfigure('project',
			     -underline => 1);
$projects_text->tagBind('project',
			"<Button-1>" =>
			sub { &start_stop($projects_text->index('current')) });
$projects_text->tagBind('project',
			"<Button-2>" =>
			sub { &show_attributes($projects_text->index('current')) });
$projects_text->tagBind('project',
			"<Button-3>" =>
			sub { &new_sub_project($projects_text->index('current')) });

my $status_frame = $top->Frame(-relief => 'ridge',
			       -bd => 1);
$status_frame->pack(-expand => 1, -fill => 'x');
my $status_text = $status_frame->Label(-text => $copyright);
$status_text->pack(-side => 'left');

$projects_text->tagBind('project',
			"<Enter>" =>
			sub { $status_text->configure(-text => $project_status); });
$projects_text->tagBind('project',
			"<Leave>" =>
			sub { $status_text->configure(-text => $copyright); });

&load_file;

MainLoop;

sub enter_label {
    my($res, $action);
    $status_text->configure(-text => 'Project name:');
    my $entry = $status_frame->Entry(-textvariable => \$res,
				     -width => 30);
    $entry->pack(-side => 'left');
    $entry->waitVisibility;
    $entry->grab;
    $entry->focus;
    $entry->bind("<Return>", sub { $action = 'yes' });
    $entry->bind("<Escape>", sub { $action = 'no' });
    $entry->waitVariable(\$action);
    $entry->grabRelease;
    $entry->destroy;
    $status_text->configure(-text => $copyright);
    $action eq 'yes' ? $res : undef;
}

sub new_project {
    my $label = &enter_label;
    if ($label) {
	my $p = $root->subproject($label);
	&insert_project($p);
    }
}

sub new_sub_project {
    my $index = shift;
    my $label = &enter_label;
    if ($label) {
	my $project_index = &get_project_index($index);
	return if !defined $project_index;
	my $p = $projects_in_text[$project_index];
	my $sub_p = $p->subproject($label);
	&insert_project($sub_p,
			"project-$project_index.last");
    }
}

sub insert_project {
    my($p, $after) = @_;
    return if $p->archived && !$show_archived;
    my $label = $p->label;
    my $indent = $p->level-1;
    $after = 'end' unless $after;
    push(@projects_in_text, $p);
    my $index = $#projects_in_text;
    $projects_in_text{$p} = $index;
    $projects_text->insert
      ($after, 
       (">" x $indent),
       ["project-$index"],
       ($p->archived ? "($label)" : $label),
       ["label-$index", "project-$index", 'project'],
       "\t" . &sec2time($p->sum_time($start_session_time, 1)) .
       "\t" . &sec2time($p->sum_time($today_time, 1)) .
       "\t" . &sec2time($p->sum_time(0, 1)) . "\n",
       ["time-$index", "project-$index"]);
}

sub start_stop {
    my $index = shift;
    my $project_index = &get_project_index($index);
    return if !defined $project_index;
    if (defined $current_project_index &&
	$current_project_index == $project_index) {
	&stop_project;
    } else {
	&start_project($project_index);
    }
}

sub get_project_index {
    my $index = shift;
    my @tags = $projects_text->tagNames($index);
    my $project_index;
    foreach (@tags) {
	if (/^project-(.*)/) {
	    $project_index = $1;
	    last;
	}
    }
    $project_index;
}

sub start_project {
    my $project_index = shift;
    &stop_project;
    $current_project_index = $project_index;
    $projects_text->tagAdd('running',
			   "label-$project_index.first",
			   "label-$project_index.last");
    $projects_in_text[$current_project_index]->start_time;
    &set_timeout();
}

sub pause {
    if (defined $current_project_index) {
	&stop_project;
    }
}

sub stop_project {
    if (defined $time_after) {
	$time_after->cancel;
	undef $time_after;
    }
    if (defined $current_project_index) {
	$projects_in_text[$current_project_index]->end_time;
	&act_time;
	undef $current_project_index;
	$projects_text->tagRemove('running', '1.0', 'end');
    }
}

sub act_time {
    my $index = shift;
    my $project_index = (defined $index ? $index : $current_project_index);
    return if !defined $project_index;
    my $project = $projects_in_text[$project_index];
    while ($project) {
	&act_time_project($project);
	$project = ($project->level > 1 ? $project->parent : undef);
    }
    &set_timeout();
}

sub act_time_project {
    my($project_index_or_ref) = @_;
    my($project, $project_index);
    if (ref $project_index_or_ref eq 'Project') {
	$project = $project_index_or_ref;
	$project_index = $projects_in_text{$project};
    } else {
	$project_index = $project_index_or_ref;
	$project = $projects_in_text[$project_index];
    }
    $projects_text->delete("time-$project_index.first",
			   "time-$project_index.last");
    $projects_text->insert
      ("label-$project_index.last",
       "\t" . &sec2time($project->sum_time($start_session_time, 1)) .
       "\t" . &sec2time($project->sum_time($today_time, 1)) .
       "\t" . &sec2time($project->sum_time(0, 1)) . "\n",
       ["time-$project_index", "project-$project_index"]);
}

sub set_timeout {
    if (defined $time_after) {
	$time_after->cancel;
    }
    $time_after = $projects_text->after
      ($time_update*1000, sub { &act_time(); } );
}

sub load_file {
    &stop_project;
    if (!$root->load($datafile)) {
	$status_text->configure(-text => "Can't load $datafile!");
	return;
    }
    &insert_all;
    &set_autosave;
    $root->modified(0);
}

sub insert_all {
    $projects_text->delete('1.0', 'end');
    @projects_in_text = ();
    %projects_in_text = ();
    foreach (@{$root->subproject}) {
	&insert_old_project($_, 0);
    }
}

sub insert_old_project {
    my($p, $indent) = @_;
    &insert_project($p);
    if (!$show_only_top) {
	foreach (@{$p->subproject}) {
	    &insert_old_project($_, $indent+1);
	}
    }
}

sub dump_data {
    print STDERR $root->dump_data();
    open(OUT, ">/tmp/timex.data") || warn "Can't write timex.data";
    print OUT $root->dump_data();
    close OUT;
}

sub old_save_file {
    if (!open(OUT, ">$datafile.data")) {
	$status_text->configure(-text => "Can't write to $datafile.data");
	return;
    }
    require Data::Dumper;
    $Data::Dumper::Purity = 1;
    $Data::Dumper::Indent = 1;
    print OUT Data::Dumper->Dump([$root], ['root']), "\n";
    close OUT;
}

sub save_file {
    my $autosave = shift;

    if (defined $current_project_index) {
	$projects_in_text[$current_project_index]->end_time;
    }

    if (!$autosave) {
	foreach (reverse(0 .. 8)) {
	    rename "$datafile.$_", "$datafile." . ($_+1);
	}
    }
    rename $datafile, "$datafile.0";

    if (!$root->save("$datafile")) {
	$status_text->configure(-text => "Can't write to $datafile");
    } else {
	$status_text->configure(-text => "Saved $datafile");
    }
    &old_save_file;

    if (defined $current_project_index) {
	$projects_in_text[$current_project_index]->unend_time;
    }

    if (!$autosave) {
	$root->modified(0);
    }

    &set_autosave;
}

sub set_autosave {
    if ($autosave) {
	if (defined $autosave_after) {
	    $autosave_after->cancel;
	}
	$autosave_after = $top->after($autosave_update*1000,
				      sub { &save_file(1) });
    }
}

sub toggle_autosave {
    &set_autosave;
    print STDERR "Autosave: $autosave\n";
}

sub toggle_dateformat {
    my $project_index;
    foreach $project_index (@projects_in_text) {
	&act_time_project($project_index);
    }
    if (&set_time_update) {
	&set_timeout;
    }
}

sub not_running {
    my($var) = @_;
    if (defined $current_project_index) {
	require Tk::Dialog;
	$top->Dialog(-title => 'Warning',
		     -text  => 
		     "Can't perform this action while project running"
		     )->Show;
	if (defined $var) {
	    # alte Einstellung wiederherstellen
	    $$var = ($$var ? 0 : 1);
	}
	return undef;
    } else {
	return 1;
    }
}

sub toggle_show_archived {
    &not_running(\$show_archived) && &insert_all;
}

sub toggle_show_only_top {
    &not_running(\$show_only_top) && &insert_all;
}

sub toggle_time_arbeitstag {
    &not_running(\$time_arbeitstag) && &insert_all;
}

sub show_attributes {
    my $index = shift;

    return if !&not_running;

    my $project_index = &get_project_index($index);
    return if !defined $project_index;
    my $project = $projects_in_text[$project_index];

    my $attribute_top = $top->Toplevel(-title => "Attributes");
    my $f = $attribute_top->Frame->pack;
    $f->Label(-text => 'Name: ')->pack(-side => 'left');
    my $label = $project->label;
    $f->Entry(-textvariable => \$label)->pack(-side => 'left');

    if ($project->parent) {
	$attribute_top->Label(-text => 'Parent: ' .
			      ($project->parent eq $root ?
			       '(Root)' : $project->parent->label)
			     )->pack(-anchor => 'w');
    }

    my $new_parent;
    my $browse = $attribute_top->BrowseEntry(-label => "New Parent",
					     -variable => \$new_parent);
    my @all_labels = @{$root->all_labels};
    foreach (@all_labels) {
	$_ = '(Root)' if $_ eq '';
	$browse->insert("end", $_);
    }
    $browse->pack;

    my $archived = $project->{'archived'};
    $attribute_top->Checkbutton(-text => 'Archived',
				-variable => \$archived
			       )->pack(-anchor => 'w');
    
    my $command_frame = $attribute_top->Frame->pack(-side => 'bottom');
    my $ok = $command_frame->Button
      (-command => sub {
	   my $insert_all;
	   if ($label && $label ne $project->label) {
	       $project->label($label);
	       $insert_all++;
	   }
	   if (defined $new_parent && grep($_ eq $new_parent, @all_labels)) {
	       my $new_parent_p;
	       if ($new_parent eq '(Root)') {
		   $new_parent_p = $root;
	       } else {
		   $new_parent_p = $root->find_by_label($new_parent);
	       }
	       if ($new_parent_p) {
		   if ($project->reparent($new_parent_p)) {
		       $insert_all++;
		   } else {
		       require Tk::Dialog;
		       $attribute_top->Dialog
			 (-title => 'Warning',
			  -text  => 
			  "Can't reparent " . $project->label . " to " .
			  $new_parent_p->label
			 )->Show;
		   }
	       }
	   }
	   $insert_all++ if ($archived && !$project->{'archived'});
	   $project->archived($archived);
	   $attribute_top->destroy();
	   &insert_all if $insert_all;
       }
      );
    &set_text_or_image($ok,
		       "/usr/www/bilder/icons/Misc2/answer_good.gif", "OK");
    $ok->pack(-side => 'left');
    my $cancel = $command_frame->Button
      (-command => sub { $attribute_top->destroy() }
      );
    &set_text_or_image($cancel,
		       "/usr/www/bilder/icons/Misc2/answer_bad.gif", "Cancel");
    $cancel->pack(-side => 'left');

    &under_mouse($attribute_top);
}

sub set_time_update {
    my $old_time_update = $time_update;
    $time_update = ($dateformat eq 'd' ? 60 : 1);
    $time_update < $old_time_update;
}

sub set_text_or_image {
    my($widget, $image, $text) = @_;
    # use image if available, else text
    if (-r $image) {
	$widget->configure(-image => $widget->Photo(-file => $image));
    } else {
	$widget->configure(-text => $text);
    }
}

sub rdonly_checkbutton {
    my $checkbutton = shift;
    $checkbutton->bind("<1>");
    $checkbutton->bind("<space>");
}

# aus ~/devel/adb/adb 
sub under_mouse {
    my($toplevel) = @_;
    $toplevel->withdraw;	# unsichtbares Update erzwingen
    $toplevel->update;
    my($scrheight, $scrwidth) 
	= ($toplevel->screenheight, $toplevel->screenwidth);
    my($x, $y) = $toplevel->pointerxy;
    # XXX leider ist req(width|height) ohne Rahmen. Deshalb addiere ich
    # etwas hinzu ...
    my($topheight, $topwidth)
	= ($toplevel->reqheight+28, $toplevel->reqwidth+6);
    my($geomheight, $geomwidth);
    $geomheight = int($y - $topheight/2);
    if ($geomheight + $topheight > $scrheight) {
	$geomheight = $scrheight - $topheight;
    }
    $geomheight = 0 if ($geomheight < 0);
    $geomwidth = int($x - $topwidth/2);
    if ($geomwidth + $topwidth > $scrwidth) {
	$geomwidth = $scrwidth - $topwidth;
    }
    $geomwidth = 0 if ($geomwidth < 0);
    $toplevel->geometry("+$geomwidth+$geomheight");
    $toplevel->deiconify;	# wieder sichtbar machen
}

sub quit_program {
    require Tk::Dialog;
    if ($root->modified || defined $current_project_index) {
	if (!defined $quit_dialog) {
	    $quit_dialog = $top->Dialog(-title => 'Quit Program',
					-text  => "Really quit?",
					-default_button => 'No',
					-buttons => ['Yes', 'No']);
	}
	return 0 if $quit_dialog->Show ne 'Yes';
    }
    $top->destroy;
}

sub sec2time {
    my $sec = shift;
    my($day, $hour, $min);
    if ($dateformat eq 'd') {
	$day = int($sec / ($time_arbeitstag ? 28800 : 86400));
	$sec = $sec % ($time_arbeitstag ? 28800 : 86400);
    }
    $hour = int($sec / 3600);
    $sec  = $sec % 3600;
    $min  = int($sec / 60);
    if ($dateformat eq 'd') {
	sprintf("%3dd %02d:%02d", $day, $hour, $min);
    } else {
	sprintf("%02d:%02d:%02d", $hour, $min, $sec % 60);
    }
}

# print out how to use this program.
# the string argument passed to it is printed at the end, with a nl.
sub usage {
    my($problem) = @_;
    require File::Basename;
    die "usage: ",
    &File::Basename::basename($0),
    " []
\n"
    . "$problem\n";
}

# Get the argument, which may be directly after this switch, or the
# next word entirely.  This works like getopts, in a way.
sub get_arg {
    my($index, $array, $prefix, $arg) = @_;
    if ($arg =~ m/^$prefix$/) {
	++$$index;
	die "Too few args - last arg was $arg\n" if ($$index > $#{$array});
	return $array->[$$index];
    } else {
	$arg =~ s/^$prefix//; return "$arg";
    }
}


=head1 TODO

 - reparent objects

=cut
