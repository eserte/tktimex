#!/usr/local/bin/perl -w
# -*- perl -*-

#
# $Id: tktimex,v 4.23 1999/02/05 21:30:14 eserte Exp $
#
# Author: Slaven Rezic
# Copyright: see in subroutine show_about or the Help/About menu entry
#
# Mail: <URL:mailto:eserte@cs.tu-berlin.de>
# WWW:  <URL:http://www.cs.tu-berlin.de/~eserte/>
# Talk: <URL:telnet://ole.cs.tu-berlin.de:1211>
#

use Tk;
use Tk::ErrorDialog;

######################################################################

package Tk::Wm;

sub Popup
{
 my $w = shift;
 $w->withdraw;        # force invisible update
 $w->configure(@_) if @_;
 $w->idletasks;
 my ($mw,$mh) = ($w->reqwidth,$w->reqheight);
 my ($rx,$ry,$rw,$rh) = (0,0,0,0);
 my $base    = $w->cget('-popover');
 my $outside = 0;
 if (defined $base)
  {
   if ($base eq 'cursor')
    {
     ($rx,$ry) = $w->pointerxy;
    }
   else
    {
     $rx = $base->rootx; 
     $ry = $base->rooty; 
     $rw = $base->Width; 
     $rh = $base->Height;
    }
  }
 else
  {
   my $sc = ($w->parent) ? $w->parent->toplevel : $w;
   $rx = -$sc->vrootx;
   $ry = -$sc->vrooty;
   $rw = $w->screenwidth;
   $rh = $w->screenheight;
  }
 my ($X,$Y) = AnchorAdjust($w->cget('-overanchor'),$rx,$ry,$rw,$rh);
 ($X,$Y)    = AnchorAdjust($w->cget('-popanchor'),$X,$Y,-$mw,-$mh);

 my ($sh,$sw) = ($w->screenheight, $w->screenwidth);
 $mw += 6; $mh += 28; # XXX for window manager frame
 if ($X + $mw > $sw) { $X = $sw - $mw }
 if ($X < 0)         { $X = 0         }
 if ($Y + $mh > $sh) { $Y = $sh - $mh }
 if ($Y < 0)         { $Y = 0         }

 $w->Post($X,$Y);
}

######################################################################

package main;

use Tk::HList;
use File::Basename;
use FindBin;
use lib ("$FindBin::RealBin");
use lib ("/home/e/eserte/lib/perl");
use lib ("/home/e/eserte/devel"); # XXX für ComboBox
eval { require Tk::UnderlineAll };
use Timex::Project;
use strict;
use vars qw($VERSION);
use locale; # for sort, broken in older FreeBSD

$VERSION = sprintf("%d.%02d", q$Revision: 4.23 $ =~ /(\d+)\.(\d+)/);

my $os = ($^O =~ /win/i ? 'win' : 'unix');

if ($Tk::VERSION <= 402.002) {
    Tk::HList->EnterMethods("Tk/HList.pm", qw(header));
}
 
my $root = new Timex::Project;

my $quit_dialog;
my $title = "tktimex $VERSION";
my $current_project = undef;
my $start_session_time = time;
my $time_after;
my $time_update = 0;
my $autosave_after;
my @nowtime = localtime;
my $today_time = time - $nowtime[0] - $nowtime[1]*60 - $nowtime[2]*60*60;
my $project_status = "Left: Select | Middle: Attributes | Right: Create Subproject";
# there are two forms of separators: for intern store in HList and in
# .tktimex.last ust $separator, for human-readable output use "/"
my $separator = '¦';
my $undo_register;
my $status_edit = 0;
my($old_last_projects, $last_projects);
my $max_last_projects = 4;

my $options = {};
my @opttable =
  (['file|f',             '=s', undef, 'subtype' => 'file'],
   ['autosave',           '!',  1,
    'callback' => \&toggle_autosave, 'alias' => ['as'] ],
   ['update',             '=i', 60*10],
   ['dateformat',         '=s', 'd',
    'choices' => ['d', 'h', 'hs'],
    'strict' => 1,
    'callback' => \&set_dateformat,
    'alias' => ['df']],
   ['day8',               '!',  0, 'callback' => \&toggle_time_arbeitstag ],
   ['archived',           '!',  0, 'callback' => \&toggle_show_archived ],
   ['onlytop',            '!',  0, 'callback' => \&toggle_show_archived ],
   ['sort',               '=s', '',
    'choices' => ['nothing', 'name', 'time'],
    'strict' => 1,
    'callback' => \&insert_all,
   ],
   ['oneday-immediately', '!',  1],
   ['geometry',           '=s', "500x230"], # XXX
  );
my $opt;
eval {
    require Tk::Getopt;
    Tk::Getopt->VERSION(0.34);
};
if ($@) {
    warn "No Tk::Getopt --- falling back to Getopt::Long\n";
    require Getopt::Long;
    my @getopt;
    push @getopt, $options;
    foreach (@opttable) {
	$options->{$_->[0]} = $_->[2] if defined $_->[2];
	push @getopt, $_->[0] . $_->[1];
    }
    die "Usage?" if !Getopt::Long::GetOptions(@getopt);
} else {
    $opt = new Tk::Getopt(-opttable => \@opttable,
			  -options  => $options,
			  -filename => "$ENV{HOME}/.tktimex");
    $opt->set_defaults;
    $opt->load_options;
    die $opt->usage if !$opt->get_options;
}
if (!$options->{'file'} and @ARGV) {
    $options->{'file'} = shift @ARGV;
}

my $top = new MainWindow;
$top->protocol('WM_DELETE_WINDOW', \&quit_program);
$top->title($title);
$top->geometry($options->{'geometry'}) if $options->{'geometry'};

my $is_archiv;
my $balloon;
if ($Tk::VERSION >= 800.005) {
    require Tk::ItemStyle; # erst ab 800.005
    $is_archiv = $top->ItemStyle('text', -foreground => 'red');

    # altes Balloon und HList vertragen sich nicht miteinander
    require Tk::Balloon;
    $balloon = $top->Balloon;
}

my $menu_frame = $top->Frame(-relief => 'raised',
			     -borderwidth => 2);

my $mb_file = $menu_frame->Menubutton(-text => 'File')->pack(-side => 'left');
$mb_file->command(-label => 'Load',
		  -command => sub { load_file(1) });
$mb_file->command(-label => 'Save',
		  -command => \&save_file);
$mb_file->cascade(-label => 'Export');
my $mb_file_menu = $mb_file->cget(-menu);
my $mb_export = $mb_file_menu->Menu;
$mb_file->entryconfigure('last', -menu => $mb_export);
$mb_export->command(-label => 'Save as ...',
		    -command => \&save_as_file);
$mb_export->command(-label => 'Save skeleton',
		    -command => \&save_skeleton);
$mb_export->command(-label => 'Save subproject',
		    -command => \&save_subproject);
$mb_export->command(-label => 'Dump',
		    -command => \&dump_data);
$mb_file->command(-label => 'Merge',
		  -command => \&merge_file);
$mb_file->command(-label => 'Quit',
		  -command => \&quit_program);
$mb_file->separator;

my $mb_project = $menu_frame->Menubutton(-text => 'Project'
					)->pack(-side => 'left');
$mb_project->command(-label => 'New',
		     -command => \&new_project);
$mb_project->command(-label => 'New subproject',
		     -command => sub { new_sub_project(get_sel_entry()) });
$mb_project->command(-label => 'Pause',
		     -command => \&pause_or_cont);
$mb_project->command(-label => 'Undo',
		     -command => \&undo);
$mb_project->command(-label => 'Continue last',
		     -command => \&cont_last);
$mb_project->command(-label => 'Attributes',
		     -command => sub { show_attributes(undef) });
$mb_project->command(-label => 'Intervals',
		     -command => sub { show_intervals($top, undef) });
$mb_project->separator;
$mb_project->command(-label => 'Working time',
		     -command => \&working_time);
$mb_project->command(-label => 'Daily details',
		     -command => \&show_one_day);

my $mb_project_menu = $mb_project->cget(-menu);

my $mb_options = $menu_frame->Menubutton(-text => 'Options'
					)->pack(-side => 'left');
$mb_options->checkbutton(-label => 'Autosave',
			 -command => \&toggle_autosave,
			 -variable => \$options->{'autosave'},
			);
$mb_options->cascade(-label => 'Dateformat');
my $mb_options_menu = $mb_options->cget(-menu);
my $dateformat_menu = $mb_options_menu->Menu;
$mb_options->entryconfigure('Dateformat', -menu => $dateformat_menu);
$mb_options->checkbutton(-label => 'day = 8h',
			 -command => \&toggle_time_arbeitstag,
			 -variable => \$options->{'day8'},
			);
$mb_options->checkbutton(-label => 'Show archived',
			 -command => \&toggle_show_archived,
			 -variable => \$options->{'archived'},
			);
$mb_options->checkbutton(-label => 'Show only top',
			 -command => \&toggle_show_only_top,
			 -variable => \$options->{'onlytop'},
			);
if (defined $opt) {
    $mb_options->separator;
    $mb_options->command(-label => 'Option editor',
			 -command => sub { $opt->option_editor($top) });
}

$dateformat_menu->radiobutton(-label => 'H:M:S',
			      -command => \&set_dateformat,
			      -value => 'hs',
			      -variable => \$options->{'dateformat'},
			     );
$dateformat_menu->radiobutton(-label => 'H:M',
			      -command => \&set_dateformat,
			      -value => 'h',
			      -variable => \$options->{'dateformat'},
			     );
$dateformat_menu->radiobutton(-label => 'd H:M',
			      -command => \&set_dateformat,
			      -value => 'd',
			      -variable => \$options->{'dateformat'},
			     );

my $mb_help = $menu_frame->Menubutton(-text => 'Help'
				     )->pack(-side => 'left');
$mb_help->command(-label => 'About',
		  -command => \&show_about);
$mb_help->command(-label => 'Index',
		  -command => sub {
		      use Tk::Pod;
		      Tk::Pod->Dir($FindBin::Bin);
		      $top->Pod(-file => "$FindBin::Script",
				-title => "tktimex",
			       );
		  });

my $save_check = $menu_frame->Checkbutton(-text => '*',
					  -variable => \$root->{'modified'},
					  -state => 'disabled',
					 )->pack(-side => 'right');
$balloon->attach($save_check, -msg => 'File saved indicator') if $balloon;

my $pause_cont_button = $menu_frame->Button
  (-text => 'Pause',
   -command => \&pause_or_cont)->pack(-side => 'right');

$menu_frame->Button(-text => 'Save',
		    -command => \&save_file)->pack(-side => 'right');

$menu_frame->pack(-fill => 'x');

my $project_frame = $top->Scrolled
  ('HList', -scrollbars => 'osoe',
   -columns => 4,
   -height => 1,
   -drawbranch => 1,
   -header => 1,
   -selectmode => 'single',
   -browsecmd => sub { pause(); },
   -separator => $separator,
  )->pack(-expand => 1, -fill => 'both');
$project_frame->header('create', 0, -text => 'Projects:');
my $pf_time_index = 1;
$project_frame->header('create', $pf_time_index, -text => 'Session');
$project_frame->header('create', $pf_time_index+1, -text => 'Today');
$project_frame->header('create', $pf_time_index+2, -text => 'Total');

my $orig_selectbg = $project_frame->cget(-selectbackground);

$project_frame->bind("<Double-ButtonRelease-1>" =>
		     sub { start_stop(shift->info('selection')) });
$project_frame->bind("<Button-2>" =>
		     sub { show_attributes(get_entry(@_)) });
$project_frame->bind("<Button-3>" =>
		     sub { new_sub_project(get_entry(@_)) });

my $status_frame = $top->Frame(-relief => 'ridge',
			       -bd => 1);
$status_frame->pack(-fill => 'x');

my $status_text = $status_frame->Label
  (-text => "Current file: " . ($options->{file} || ""));
$status_text->pack(-side => 'left');

# verzögert zeigen, da evtl. wichtige Statusmeldungen dadurch
# verdeckt werden ... aber nicht, wenn in der Statuszeile editiert wird!
my $status_timer;
$project_frame->bind
  ("<Enter>" => sub {
       if ($status_timer) {
	   $status_timer->cancel;
	   undef $status_timer;
       }
       $status_timer = $project_frame->after
	 (3000, sub { $status_text->configure(-text => $project_status)
			unless $status_edit;
		  })
     });
$project_frame->bind
  ("<Leave>" => sub {
       if ($status_timer) {
	   $status_timer->cancel;
	   undef $status_timer;
       }
       $status_timer = $project_frame->after
	 (3000, sub { $status_text->configure
			(-text => "Current file: " . ($options->{file} || ""))
			  unless $status_edit;
		  })
     });

$menu_frame->UnderlineAll if $menu_frame->can('UnderlineAll');

$opt->process_options if defined $opt;

&set_time_update();

$root->modified(0);
# if (!$options->{'file'}) {
#     my $file = get_filename($top,
# 			    -Title => 'Enter project file',
# 			    -File => 'mytimex.pj1',
# 			    -FPat => '*.pj1',
# 			    -Create => 0);
#     if ($file) {
# 	$file = adjust_filename($file);
# 	$options->{'file'} = $file;
#     } else {
# 	die "No project file specified";
#     }
# }
if ($options->{'file'}) {
    load_file(0);
    load_last_projects();
    create_menu_last_projects();
}

$project_frame->focus;

$top->repeat(5*60*1000, \&check_still_today);

MainLoop;

sub enter_label {
    my $action;
    my $res = '';
    $status_edit++;
    $status_text->configure(-text => 'Project name:');
    my $entry = $status_frame->Entry(-textvariable => \$res,
				     -width => 30);
    $entry->pack(-side => 'left');
    $entry->waitVisibility;
    $entry->grab;
    $entry->focus;
    $entry->bind("<Return>", sub { $action = 'yes' });
    $entry->bind("<Escape>", sub { $action = 'no' });
    $entry->OnDestroy(sub { $status_edit-- });
    $entry->waitVariable(\$action);
    $entry->grabRelease;
    $entry->destroy;
    $status_text->configure(-text => "Current file: " . 
			    ($options->{file} || ""));
    if ($action eq 'yes') {
	$res =~ s/$separator//g; # sicherheitshalber ...
	$res;
    } else {
	undef;
    }
}

sub new_project {
    my $label = &enter_label;
    if ($label) {
	my $p = $root->subproject($label);
	&insert_project($p);
#	$project_frame->idletasks; # XXX see-bug
	$project_frame->see(make_path($p));
    }
}

sub new_sub_project {
    my $path = shift;
    return if !defined $path;
    my $label = &enter_label;
    if ($label) {
	my $p = entry_to_project($path);
	return if !$p;
	my $sub_p = $p->subproject($label);
	&insert_project($sub_p);
#	$project_frame->idletasks; # XXX see-bug
	$project_frame->see(make_path($sub_p));
    }
}

sub insert_project {
    my($p) = @_;
    return if !$p || ($p->archived && !$options->{'archived'});
    my $label = $p->label;
    my $path = make_path($p);
    return if !$path;
    $project_frame->add($path,
			-text => $p->label,
			-itemtype => 'text',
			-data => $p);
    if ($p->archived && $is_archiv) {
	$project_frame->itemConfigure($path, 0, -style => $is_archiv);
    }
    $project_frame->itemCreate
      ($path, $pf_time_index, -itemtype => 'text',
       -text => &sec2time($p->sum_time($start_session_time, undef,
				       -recursive => 1)));
    $project_frame->itemCreate
      ($path, $pf_time_index+1, -itemtype => 'text',
       -text => &sec2time($p->sum_time($today_time, undef,
				       -recursive => 1)));
    $project_frame->itemCreate
      ($path, $pf_time_index+2, -itemtype => 'text',
       -text => &sec2time($p->sum_time(0, undef,
				       -recursive => 1)));

    for ($pf_time_index .. $pf_time_index+1) {
	$project_frame->column('width', $_, '');
# XXX geht nur über DiStyle
#	$project_frame->itemConfigure($path, $_, -anchor => 'e');
    }
}

sub start_stop {
    my $path = shift;
    return if !$project_frame->info('exists', $path);
    my $p = $project_frame->info('data', $path);
    return if !$p;
    if (defined $current_project && $current_project eq $p) {
	&pause_or_cont;
    } else {
	&start_project($p);
    }
}

sub common_start_project {
    my $p = shift;
    stop_project();
    $current_project = $p;
    my $current_pathname = $p->pathname($separator);
    $project_frame->selectionClear;
    $project_frame->selectionSet($current_pathname);
    $project_frame->configure(-selectbackground => 'SeaGreen3');
    $project_frame->see($current_pathname);
    gui_set_pause_or_cont('Pause');

    $top->title($title . " (" . $p->pathname . ")");
    add_last_projects($current_pathname);
    set_timeout();
}

sub start_project {
    my $p = shift;
    common_start_project($p);
    $p->start_time;
}

sub pause {
    if (defined $current_project) {
	&stop_project;
	gui_set_pause_or_cont('Cont');
    }
}

sub pause_or_cont {
    if (defined $current_project) {
	&stop_project;
	gui_set_pause_or_cont('Cont');
    } else {
	my $p = get_project_from_selection();
	return if !$p;
	start_project($p);
    }
}

sub cont_last {
    return if !not_running();
    my $p = get_project_from_selection();
    return if !@{$p->{'times'}};
    my $last = $p->{'times'}[$#{$p->{'times'}}];
    require Tk::Dialog;
    my $d = $top->Dialog
      (-title => 'Continue last',
       -text  => "Really continue time from last activity?",
       -default_button => 'No',
       -buttons => ['Yes', 'No'],
       -popover => 'cursor',
      );
    return if $d->Show eq 'No';
    $p->unend_time;
    insert_all(); # XXX Optimierung: nur aktuelles Projekt modifizieren
    common_start_project($p);
}

sub get_project_from_selection {
    my $sel = $project_frame->selectionGet;
    if ($sel) {
	return $project_frame->info('data', $sel);
    }
    undef;
}

sub gui_set_pause_or_cont {
    my $txt = shift;
    $pause_cont_button->configure(-text => $txt);
    my $search_txt = ($txt eq 'Cont' ? 'Pause' : 'Cont');
    my $i;
    for $i (0 .. $mb_project_menu->index('end')) {
	if ($mb_project_menu->type($i) eq 'command' &&
	    $mb_project_menu->entrycget($i, -label) eq $search_txt) {
	    $mb_project_menu->entryconfigure($i, -label => $txt);
	    last;
	}
    }
}

sub stop_project {
    if (defined $time_after) {
	$time_after->cancel;
	undef $time_after;
    }
    if (defined $current_project) {
	$current_project->end_time;
	&act_time;
	undef $current_project;
	if ($options->{'autosave'}) {
	    save_file(); # nach undef $current_project!!!
	}
	$project_frame->configure(-selectbackground => $orig_selectbg);
	$top->title($title);
	create_menu_last_projects();
    }
}

sub undo {
    return if !defined $current_project;

    require Tk::Dialog;
    my $d = $top->Dialog(-title => 'Undo',
			 -text  => "Really undo last start?",
			 -default_button => 'No',
			 -buttons => ['Yes', 'No'],
			 -popover => 'cursor',
			);
    return if $d->Show eq 'No';

	my $p = $current_project;
    &stop_project;
    $undo_register = pop(@{$p->{'times'}});
    &act_time($p);
}

sub act_time {
    my $p = shift;
    if (!$p) {
	$p = $current_project;
	return if !$p;
    }
    my $project = $p;
    while ($project) {
	&act_time_project($project);
	$project = ($project->level > 1 ? $project->parent : undef);
    }
    &set_timeout();
}

sub act_time_project {
    my($p) = @_;
    my $path = make_path($p);
    return if !$path;
    $project_frame->itemConfigure
      ($path, $pf_time_index,
       -text => &sec2time($p->sum_time($start_session_time, undef,
				       -recursive => 1,
				       -usecache => 1)));
    $project_frame->itemConfigure
      ($path, $pf_time_index+1,
       -text => &sec2time($p->sum_time($today_time, undef,
				       -recursive => 1,
				       -usecache => 1)));
    $project_frame->itemConfigure
      ($path, $pf_time_index+2,
       -text => &sec2time($p->sum_time(0, undef,
				       -recursive => 1,
				       -usecache => 1)));
}

sub set_timeout {
    if (defined $time_after) {
	$time_after->cancel;
    }
    $time_after = $project_frame->after
      ($time_update*1000, sub { &act_time(); } );
}

sub working_time {
    my $sum = 0;
    my $week_days = 7;
    my $week_work_days = 5;
    my $month_days = 7*4;
    my $month_work_days = 5*4;
    my $last_4week_time = $today_time - 86400*$month_days;
    my $last_week_time = $today_time - 86400*$week_days;
    my $yesterday_time = $today_time - 86400;
    my $last_4week_sum = 0;
    my $last_week_sum = 0;
    my $yesterday_sum = 0;
    foreach ($root->subproject) {
	my $project_today_time = $_->sum_time($today_time, undef,
					      -recursive => 1);
	$sum += $project_today_time;
	$yesterday_sum
	  += $_->sum_time($yesterday_time, undef,
			  -recursive => 1) - $project_today_time;
	$last_week_sum
	  += $_->sum_time($last_week_time, undef, -recursive => 1);
	$last_4week_sum
	  += $_->sum_time($last_4week_time, undef, -recursive => 1);
    }

    require Tk::DialogBox;
    my $d = $top->DialogBox(-title => 'Today\'s time',
			    -buttons => ['OK'],
			    -popover => 'cursor',
			   );
    my $gridy = 0;
    $d->add('Label',
	    -text => "Today\'s working time:")->grid(-row => $gridy, 
						     -column => 0,
						     -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($sum, 'h', 0))->grid(-row => $gridy,
						   -column => 1,
						   -sticky => 'w');
    $gridy++;
    $d->add('Label',
	    -text => "Yesterday\'s working time:")->grid(-row => $gridy,
							 -column => 0,
							 -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($yesterday_sum, 'h', 0))->grid(-row => $gridy,
							     -column => 1,
							     -sticky => 'w');
    $gridy++;
    $d->add('Label')->grid(-row => $gridy, -column => 0);
    $gridy++;
    $d->add('Label',
	    -text => "Last week\'s working time (8h-day):"
	   )->grid(-row => $gridy,
		   -column => 0,
		   -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_week_sum, 'd', 1))->grid(-row => $gridy,
							     -column => 1,
							     -sticky => 'w');
    $gridy++;
    $d->add('Label',
	    -text => "  Average per working day:")->grid(-row => $gridy,
							 -column => 0,
							 -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_week_sum/$week_work_days, 'h', 0)
	   )->grid(-row => $gridy,
		   -column => 1,
		   -sticky => 'w');
    $gridy++;
    $d->add('Label')->grid(-row => $gridy, -column => 0);
    $gridy++;
    $d->add('Label',
	    -text => "Last 4 week\'s working time (8h-day): "
	   )->grid(-row => $gridy,
		   -column => 0,
		   -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_4week_sum, 'd', 1))->grid(-row => $gridy,
							      -column => 1,
							      -sticky => 'w');
    $gridy++;
    $d->add('Label',
	    -text => "  Average per working day:")->grid(-row => $gridy,
							 -column => 0,
							 -sticky => 'w');
    $d->add('Label',
	    -text => sec2time($last_4week_sum/$month_work_days, 'h', 0)
	   )->grid(-row => $gridy,
		   -column => 1,
		   -sticky => 'w');
    $d->Show;
}

sub show_one_day {
    eval { require Tk::Date };
    my $has_date = !$@;
    if (!$has_date) {
	require Time::Local;
    }
    my $f = $top->Toplevel(-title => 'Show one day');
    my $btn;
    my @p; # project array for one day
    my $dw;
    if ($has_date) {
	$dw = $f->Date
	  (-fields => 'date',
	   -value => 'now',
	   -datefmt => "%12A, %2d.%2m.%4y",
	   -choices => [qw(today yesterday),
			['one week before' => sub { time()-86400*7}],
			['four weeks before' => sub { time()-86400*7*4}],
		       ],
	   -command => sub {
	       if ($options->{'oneday-immediately'}) {
		   $btn->invoke;
	       }
	   }
	  )->pack;
    } else {
	$dw = $f->Entry->pack;
	my(@l) = localtime;
	$dw->insert(0, "$l[3]." . ($l[4]+1) . "." . ($l[5]+1900));
	$dw->bind('<Return>' => sub {
		      if ($options->{'oneday-immediately'}) {
			  $btn->invoke;
		      }
		  });
    }
    my $ff = $f->Frame->pack;
    $btn = $ff->Button(-text => 'Show')->pack(-side => 'left');
    my $clb = $ff->Button(-text => 'Close',
			  -command => sub { $f->destroy },
			 )->pack(-side => 'left');
    $f->bind('<Escape>' => sub { $clb->invoke });
    $ff->Checkbutton(-text => 'immediately',
		     -variable => \$options->{'oneday-immediately'},
		     -command => sub { 
			 $btn->invoke;
		     },
		    )->pack(-side => 'left');
    my $until_now = 0;
    $ff->Checkbutton(-text => 'till today',
		     -variable => \$until_now,
		     -command => sub {
			  if ($options->{'oneday-immediately'}) {
			      $btn->invoke;
			  }
		      },
		    )->pack(-side => 'left');
    my $lb = $f->Scrolled('HList',
			  -columns => 2,
			  -width => 40,
			  -header => 1,
			  -scrollbars => 'osoe',
			  -command => sub {
			      show_intervals($f, $p[$_[0]]) 
			  },
			 )->pack(-expand => 1,
				 -fill => 'both');
    $btn->configure(-command => sub {
		      my $s_from;
		      if ($has_date) {
			  $s_from = $dw->get("%s");
		      } else {
			  my $s = $dw->get;
			  my($d,$m,$y) = split(/\D/, $s);
			  return if !($d >= 1 && $d <= 31 &&
				      $m >= 1 && $m <= 12 &&
				      defined $y);
			  $y -= 1900 if $y > 1900;
			  $s_from = Time::Local::timelocal(0, 0, 0,
							   $d, $m-1, $y);
		      }
		      my $s_to = ($until_now ? time() : $s_from + 86400);
		      @p = $root->projects_by_interval($s_from, $s_to);
		      $lb->delete('all');
		      my $i = 0;
		      my $sum = 0;
		      foreach (@p) {
			  $lb->add($i, -text => $_->pathname);
			  my $diff = $_->sum_time($s_from, $s_to);
			  $sum += $diff;
			  $lb->itemCreate($i, 1, -text =>
					  sec2time($diff, undef, undef));
			  $i++;
		      }
		      $lb->header('create', 0, -text => '*** sum ***');
		      $lb->header('create', 1, -text =>
				  sec2time($sum, undef, undef));
		  });

    if ($options->{'oneday-immediately'}) { $btn->invoke }
    $f->Popup(-popover => 'cursor');
}

sub load_file {
    my $interactive = shift;

    if ($root->modified || defined $current_project) {
	require Tk::Dialog;
	my $dialog = $top->Dialog(-title => 'Load',
				  -text  => "Load project data (overwrite current data)?",
				  -default_button => 'No',
				  -buttons => ['Yes', 'No'],
				  -popover => 'cursor',
				 );
	return if $dialog->Show eq 'No';
    }
    &stop_project;

    my $file_to_load = $options->{'file'};

    if ($interactive) {
	my($file, $path) = fileparse($options->{'file'});

	$file_to_load = get_filename($top,
				     -Title  => 'Enter project file',
				     -File   => $file,
				     -Path   => $path,
				     -FPat   => '*.pj1',
				     -Create => 0);
	return if !$file_to_load;
    }

    my $load_root = new Timex::Project;
    if (!$load_root->load($file_to_load)) {
	$status_text->configure(-text => $@);
	return;
    }
    $root->delete_all;
    $root = $load_root;
    $options->{'file'} = $file_to_load;

    $status_text->configure(-text => "Loaded $options->{file}");
    &insert_all;
    &set_autosave;
    $root->modified(0);
    $save_check->configure(-variable => \$root->{'modified'});
    my $last_project = $root->last_project;
    if ($last_project) {
	my $last_project_path = make_path($last_project);
	if ($project_frame->info('exists', $last_project_path)) {
	    $project_frame->selectionSet($last_project_path);
#	    $project_frame->idletasks; # XXX see-bug
	    $project_frame->see($last_project_path);
	    gui_set_pause_or_cont('Cont');
	}
    }
}

sub insert_all {
    $top->Busy;
    $project_frame->delete('all');
    foreach ($root->sorted_subprojects($options->{'sort'})) {
	&insert_old_project($_);
    }
    if (defined $current_project) {
	$project_frame->selectionSet(make_path($current_project));
    }
    $top->Unbusy;
}

sub insert_old_project {
    my($p) = @_;
    &insert_project($p);
    if (!$options->{'onlytop'}) {
	foreach ($p->sorted_subprojects($options->{'sort'})) {
	    &insert_old_project($_);
	}
    }
}

sub dump_data {
    print STDERR $root->dump_data();
    if (!open(OUT, ">/tmp/timex.data")) {
	$status_text->configure(-text => "Can't write to timex.data: $!");
	return;
    }
    print OUT $root->dump_data();
    close OUT;
}

sub old_save_file {
    eval { require Data::Dumper };
    if ($@) {
	$status_text->configure(-text => $@);
	return;
    }

    return if (!$options->{'file'});

    my $datafile = "$options->{'file'}.data";
    if ($^O =~ /(mswin|dos)/i) {
	$datafile =~ s/\.pj1//; # strip first extension
    }

    if (!open(OUT, ">$datafile")) {
	$status_text->configure
	  (-text => "Can't write to <$datafile>: $!");
	return;
    }
    my $dd = new Data::Dumper [$root], ['root'];
    eval { $dd->Purity(1)->Indent(1) }; # for versions before 2.081
    my $dump;
    eval { $dump = $dd->Dumpxs };
    if ($@) {
	$dump = $dd->Dump;
    }
    print OUT $dump, "\n";
    close OUT;
}

sub save_file {
    if (!$options->{'file'}) {
	return save_as_file(@_);
    }

    my $autosave = shift;

    if (defined $current_project) {
	$current_project->end_time;
    }

    if (!$autosave) {
	foreach (reverse(0 .. 8)) {
	    rename "$options->{'file'}.$_", "$options->{'file'}." . ($_+1);
	}
	save_last_projects();
    }
    rename $options->{'file'}, "$options->{'file'}.0";

    if (!$root->save("$options->{'file'}")) {
	$status_text->configure(-text => $@);
    } else {
	$status_text->configure(-text => "Saved <$options->{'file'}>");
    }
    &old_save_file;

    if (defined $current_project) {
	$current_project->unend_time;
    }

    if (!$autosave) {
	$root->modified(0);
    }

    &set_autosave;
}

sub save_as_file {
    my $autosave = shift;

    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter project file',
			 -File => $file,
			 -Path => $path,
			 -FPat => '*.pj1',
			 -Create => 1);
    return unless $file;

    $file = adjust_filename($file);
    $options->{'file'} = $file;

    save_file($autosave);
}

sub _overwrite_warning {
    my $file = shift;
    if (-e $file) {
	require Tk::Dialog;
	die if ($top->Dialog
		(-title => 'Warning',
		 -text => "Really overwrite $file with skeleton data?\n".
		 "All time information will be lost in $file!",
		 -popover => 'cursor',
		 -default_button => 'No',
		 -buttons => ['Yes', 'No'])->Show ne 'Yes');
    }
}

sub save_skeleton {
    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter skeleton project file',
			 -Path => $path,
			 -FPat => '*.pj1',
			 -Create => 1);
    return unless $file;
    $file = adjust_filename($file);
    eval {
	_overwrite_warning($file);
    };
    return if ($@);

    $root->save($file, -skeleton => 1);
}

sub save_subproject {
    my $p = get_project_from_selection();
    return if !$p;
    my($file, $path) = get_file_path();
    $file = get_filename($top,
			 -Title => 'Enter project file',
			 -Path => $path,
			 -FPat => '*.pj1',
			 -Create => 1);
    return unless $file;
    $file = adjust_filename($file);
    eval {
	_overwrite_warning($file);
    };
    return if ($@);

    $p->save($file);
}


sub merge_file {
    my $path;
    (undef, $path) = fileparse($options->{'file'});
    my $file = get_filename($top,
			    -Title => 'Enter project file for merge',
			    -Path => $path,
			    -FPat => '*.pj1',
			    -Create => 0);
    return unless $file;

    my $new_project = new Timex::Project;
    if (!$new_project->load($file)) {
	$status_text->configure(-text => $@);
	return;
    }
    my $diff = $root->merge($new_project);
    &insert_all;
    $status_text->configure
      (-text => "Merge completed with $diff differences"); 
}

sub get_filename {
    my($top, %args) = @_;
    my %change_opt;
    my $defaultextension;
    if ($args{'-FPat'}) {
	if ($Tk::VERSION <= 800.011) {
	    ($defaultextension = $args{'-FPat'}) =~ s/^\*\.//;
	} else {
	    ($defaultextension = $args{'-FPat'}) =~ s/^\*//;
	}
    }
    if ($args{-Create} && $top->can('getSaveFile')) {
	my $file = $top->getSaveFile
	  (-initialdir => $args{-Path},
	   -initialfile => $args{'File'},
	   -defaultextension => $defaultextension,
	   -title => $args{-Title});
	return $file;
    } elsif (!$args{-Create} && $top->can('getOpenFile')) {
	my $file = $top->getOpenFile
	  (-initialdir => $args{-Path},
	   -defaultextension => $defaultextension,
	   -title => $args{-Title},
	   ($Tk::VERSION >= 800.012 ?
	    (-filetypes => [['Timex files', '.pj1'],
			    ['All files',  '*']])
	    : ()
	   ),
	  );
	return $file;
    }

    my $filedialog = 'FileDialog';
    if ($os eq 'win') {
	$@ = "XXX Tk::FileDialog does not work with win32";
    } else {
	eval { require Tk::FileDialog };
    }
    if ($@) {
	warn "Harmless warning:\n$@\n";
	require Tk::FileSelect;
	$filedialog = 'FileSelect';
	%change_opt = (-FPat   => '-filter',
		       -Path   => '-directory',
		       -File   => undef,
		       -Create => undef,
		       -Title  => undef,
		      );
    }
    foreach (keys %args) {
	if (exists $change_opt{$_}) {
	    if (defined $change_opt{$_}) {
		$args{$change_opt{$_}} = delete $args{$_};
	    } else {
		delete $args{$_};
	    }
	}
    }
    my $fd = $top->$filedialog(%args);
    $fd->Show(-popover => 'cursor');
}

sub get_file_path {
    my($file, $path);
    if ($options->{'file'}) {
	($file, $path) = fileparse($options->{'file'});
    } else {
	$file = "";
	$path = $ENV{HOME} || "/";
    }
    ($file, $path);
}

sub set_autosave {
    if ($options->{'autosave'}) {
	if (defined $autosave_after) {
	    $autosave_after->cancel;
	}
	$autosave_after = $top->after($options->{'update'}*1000,
				      sub { &save_file(1) });
    }
}

sub toggle_autosave {
    &set_autosave;
}

sub set_dateformat {
    &insert_all;
    if (&set_time_update) {
	&set_timeout;
    }
}

sub not_running {
    my($var) = @_;
    if (defined $current_project) {
	require Tk::Dialog;
	$top->Dialog(-title => 'Warning',
		     -text  => 
		     "Can't perform this action while project running",
		     -popover => 'cursor',
		     )->Show;
	if (defined $var) {
	    # alte Einstellung wiederherstellen
	    $$var = ($$var ? 0 : 1);
	}
	return undef;
    } else {
	return 1;
    }
}

sub toggle_show_archived {
    if (&not_running(\$options->{'archived'})) {
	&insert_all;
    }
}

sub toggle_show_only_top {
    &not_running(\$options->{'onlytop'}) && &insert_all;
}

sub toggle_time_arbeitstag {
    &insert_all;
}

sub show_attributes {
    my($path, $readonly) = @_;

    if (defined $current_project) { $readonly = 1 }

    if (!defined $path) {
	$path = get_sel_entry();
	return if !defined $path;
    }

    my $project = $project_frame->info('data', $path);
    return if !defined $project;

    my $attribute_top = $top->Toplevel(-title => "Attributes");
    my $f = $attribute_top->Frame->pack(-fill => 'both', -expand => 1);
    my $row = 0;
    $f->Label(-text => 'Name: ')->grid(-row => $row, -column => 0,
				       -sticky => 'w');
    my $label = $project->label;
    my $name_entry = $f->Entry(-textvariable => \$label
			      )->grid(-row => $row, -column => 1,
				      -sticky => 'w');
    if ($readonly) { $name_entry->configure(-state => 'disabled') }
    
    if ($project->parent) {
	$row++;
	$f->Label(-text => 'Parent:')->grid(-row => $row,
					    -column => 0,
					    -sticky => 'w');
	$f->Label(-text => ($project->parent eq $root ?
			    '(Root)' : $project->parent->label)
		 )->grid(-row => $row, -column => 1,
			 -sticky => 'w');
    }

    my $new_parent;
    my($combo, %combo_args);
  TRYCOMBO: {
	eval {
	    die "Don't use ComboBox";
	    require ComboBox; # XXX Tk::
	    $combo = 'ComboBox'; 
	    %combo_args = (-caseless => 'on', # XXX
			   -match => 'on');
	};
	last TRYCOMBO if (defined $combo);
	require Tk::BrowseEntry;
	$combo = 'BrowseEntry';
    }
    $row++;
    my $browse = $f->$combo(-label => "New Parent",
			    -variable => \$new_parent,
			    %combo_args);
    if ($readonly) {
	$browse->configure(-state => 'disabled')
    }
    my(@all_labels) = sort { lc($a) cmp lc($b) } $root->all_pathnames;
    foreach (@all_labels) {
	$_ = '(Root)' if !defined $_ || $_ eq '';
	$browse->insert("end", $_);
    }
    $browse->grid(-row => $row, -column => 0,
		  -columnspan => 3, -sticky => 'w');
    
    my $archived = $project->{'archived'};
    $row++;
    my $arch_check = $f->Checkbutton
      (-text => 'Archived',
       -variable => \$archived
      )->grid(-row => $row, -column => 0, -sticky => 'w');
    if ($readonly) { $arch_check->configure(-state => 'disabled') }

    my $rcsfile = $project->rcsfile;
    $row++;
    $f->Label(-text => 'RCS file:'
	     )->grid(-row => $row, -column => 0, -sticky => 'w');
    $f->Entry(-textvariable => \$rcsfile
	     )->grid(-row => $row, -column => 1, -sticky => 'w');
    $f->Button
      (-text => 'Browse...',
       -command => sub {
	   my($file, $path) = fileparse($rcsfile) if $rcsfile;
	   my $newfile = get_filename($attribute_top,
				      -Title  => 'RCS file',
				      ($rcsfile ? (-File   => $file,
						   -Path   => $path) : ()),
				      -Create => 0,
				     );
	   if ($newfile) {
	       $rcsfile = $newfile;
	       
	   }
       })->grid(-row => $row, -column => 2, -sticky => 'w');

    $row++;
    $f->Button(-text => 'Show intervals',
	       -command => sub {
		   show_intervals($f,
				  $project,
				  -readonly => $readonly);
	       })->grid(-row => $row, -column => 0,
			-columnspan => 3, -sticky => 'w');

    my $command_frame = $attribute_top->Frame->pack(-fill => 'x',
						    -expand => 1);
    my $ok = $command_frame->Button
      (-command => sub {
	   my $insert_all;
	   if ($label && $label ne $project->label) {
	       $project->label($label);
	       $insert_all++;
	   }
	   if (defined $new_parent && grep($_ eq $new_parent, @all_labels)) {
	       my $new_parent_p;
	       if ($new_parent eq '(Root)') {
		   $new_parent_p = $root;
	       } else {
		   $new_parent_p = $root->find_by_label($new_parent);
	       }
	       if ($new_parent_p) {
		   if ($project->reparent($new_parent_p)) {
		       $insert_all++;
		   } else {
		       require Tk::Dialog;
		       $attribute_top->Dialog
			 (-title => 'Warning',
			  -text  => 
			  "Can't reparent " . $project->label . " to " .
			  $new_parent_p->label,
			  -popover => 'cursor',
			 )->Show;
		   }
	       }
	   }
	   $insert_all++ if ($archived && !$project->{'archived'});
	   $project->archived($archived);
	   $project->rcsfile($rcsfile);
	   $attribute_top->destroy();
	   &insert_all if $insert_all;
       }
      );
    &set_text_or_image($ok, "yes.gif", "OK");
    $ok->pack(-side => 'left');
    my $cancel = $command_frame->Button
      (-command => sub { $attribute_top->destroy() }
      );
    $attribute_top->bind('<Escape>' => sub { $cancel->invoke });
    &set_text_or_image($cancel, "no.gif", "Cancel");
    $cancel->pack(-side => 'left');
    $attribute_top->Popup(-popover => 'cursor');
}

sub show_intervals {
    my($top, $project, %args) = @_;

    my $readonly      = $args{-readonly};
    my $show_seconds  = $args{-show_seconds};
    my $geometry      = $args{-geometry};
    my $modified      = $args{-modified};

    if (!defined $project) {
	$project = entry_to_project(get_sel_entry());
	return if !defined $project;
    }

    my @rev;
    if ($project->rcsfile) {
	eval {
	    require Timex::Rcs;
	    my $rcs = new Timex::Rcs $project->rcsfile;
	    if ($rcs) {
		foreach my $rev ($rcs->revisions) {
		    push(@rev, [$rev->revision,
				$rev->unixtime,
				$rcs->symbolic_name($rev)]);
		}
	    } else {
		die "Can't create rcs object";
	    }
	};
	warn $@ if $@;
    }

    my($w, $lb);

    my $update = sub {
	my $t = shift;
	$t->destroy if $t;
	my $geometry = $w->geometry,
	$w->destroy;
	show_intervals($top, $project,
		       -readonly     => $readonly,
		       -show_seconds => $show_seconds,
		       -modified     => $modified,
		       # XXX geht nicht? -geometry     => $geometry,
		      );
    };

    my $interval_editor = sub {
	my $i = shift;
	return if $readonly;
	require Tk::Date;
	my $t = $w->Toplevel(-title => "Edit line $i");
	if ($geometry) {
	    $t->geometry($geometry);
	}
	my($from, $to) = @{$project->{'times'}[$i]};
	$t->Label(-text => 'From:')->grid(-row => 0, -column => 0);
	my $from_date = $t->Date(-variable => \$from,
				 -choices => 'now',
				)->grid(-row => 0, -column => 1);
	$t->Label(-text => 'To:')->grid(-row => 1, -column => 0);
	my $to_date = $t->Date(-variable => \$to,
			       -choices => 'now',
			      )->grid(-row => 1, -column => 1);
	my $f = $t->Frame->grid(-row => 2, -column => 0, -columnspan => 2);

	my $okb = $f->Button
	  (-text => 'OK',
	   -command => sub {
	       $project->set_times($i, $from, $to);
	       $update->($t);
	   },
	  )->pack(-side => 'left');
	my $cancelb = $f->Button
	  (-text => 'Cancel',
	   -command => sub {
	       $t->destroy;
	   },
	  )->pack(-side => 'left');
	my $deleteb = $f->Button
	  (-text => 'Delete',
	   -command => sub {
	       $project->delete_times($i);
	       $update->($t);
	   },
	  )->pack(-side => 'left');
	$t->bind('<Return>' => sub { $okb->invoke });
	$t->bind('<Escape>' => sub { $cancelb->invoke });
	$t->Popup(-popover => 'cursor');
    };

    $w = $top->Toplevel(-title => "Intervals for " . $project->pathname);
    my $no_cols = 3;
    $no_cols += 2 if $show_seconds;
    $no_cols ++   if @rev;
    $lb = $w->Scrolled('HList', -scrollbars => 'osoe',
		       -columns => $no_cols,
		       -width => 80,
		       -header => 1,
		       -command => $interval_editor,
		      )->pack(-fill => 'both', -expand => 1);
    {
	my $col = 0;
	$lb->header('create', $col++, -text => 'From');
	$lb->header('create', $col++, -text => 'seconds')
	  if $show_seconds;
	$lb->header('create', $col++, -text => 'To');
	$lb->header('create', $col++, -text => 'seconds')
	  if $show_seconds;
	$lb->header('create', $col++, -text => 'Time');
	$lb->header('create', $col++, -text => 'RCS')
	  if @rev;
    }
    my $i = 0;
    foreach (@{$project->{'times'}}) {
	my($from, $to) = @$_;
	my(@fromdate) = localtime($from);
	$fromdate[4]++;
	$fromdate[5]+=1900;
	my $fromdate = sprintf
	  "%02d.%02d.%04d %02d:%02d:%02d", @fromdate[3,4,5,2,1,0];
	$lb->add($i, -text => $fromdate);
	my $col = 1;
	$lb->itemCreate($i, $col++, -text => $from)
	  if $show_seconds;

	my(@todate, $todate);
	if (defined $to) {
	    @todate = localtime($to);
	    $todate[4]++;
	    $todate[5]+=1900;
	    $todate = sprintf
	      "%02d.%02d.%04d %02d:%02d:%02d", @todate[3,4,5,2,1,0];
	    $lb->itemCreate($i, $col++, -text => $todate);
	    $lb->itemCreate($i, $col++, -text => $to)
	      if $show_seconds;
	    $lb->itemCreate($i, $col++, -text => sec2time($to-$from, 'h', 0));
	    my @t;
	    foreach my $rev (@rev) {
		if ($rev->[1] >= $from and $rev->[1] <= $to) {
		    my $t = $rev->[0];
		    if ($rev->[2]) { $t .= " (" . $rev->[2] . ")" }
		    push(@t, $t);
		}
	    }
	    if (@t) { $lb->itemCreate($i, $col++, -text => join(", ", @t)) }
	} else {
	    $lb->itemCreate($i, $col++, -text => 'Running');
	}
	$i++;
    }

    $w->withdraw;
# $lb->idletasks; # XXX see-bug
    $lb->see($i-1) if $i > 1;
    my $f = $w->Frame->pack(-fill => 'x');
    my $close_sub = sub {
	&insert_all if $modified;
	$w->destroy;
    };
    $w->protocol('WM_DELETE_WINDOW', $close_sub);
    my $clb = $f->Button(-text => 'Close',
			 -command => $close_sub,
			)->pack(-side => 'left');
    $f->Label(-text => '  ')->pack(-side => 'left');
    $f->Button(-text => 'Delete',
	       -command => sub { 
		   $project->delete_times($lb->info('selection'));
		   $modified++;
		   $update->();
	       }
	      )->pack(-side => 'left');
    $f->Button(-text => 'Insert',
	       -command => sub {
		   my @sel = $lb->info('selection');
		   my $before = (!@sel ? -1 : $sel[$#sel]);
		   $project->insert_times_after($before,
						time, time);
		   $modified++;
		   $interval_editor->($before+1);
		   #$update->();
	       }
	      )->pack(-side => 'left');
    $f->Button(-text => 'Re-Sort',
	       -command => sub {
		   $project->sort_times;
		   # $modified++ nicht notwendig, weil sich nichts an der
		   # Gesamtzeit ändert
		   $update->();
	       }
	      )->pack(-side => 'left');
    $f->Label(-text => '  ')->pack(-side => 'left');
    $f->Checkbutton(-text => 'Show seconds',
		    -variable => \$show_seconds,
		    -command => sub { $update->() },
		   )->pack(-side => 'left');
    $clb->focus;
    $w->bind('<Escape>' => sub { $clb->invoke });
    $w->Popup(-popover => 'cursor')
      unless $geometry;
}

sub set_time_update {
    my $old_time_update = $time_update;
    $time_update = ($options->{'dateformat'} eq 'hs' ? 1 : 60);
    $time_update < $old_time_update;
}

sub set_text_or_image {
    my($widget, $image, $text) = @_;
    # use image if available, otherwise text
    if (-r $image) {
	eval { $widget->configure
		 (-image => $widget->Photo(-file => Tk::findINC($image)))
	     };
	if (!$@) { return }
    } 
    $widget->configure(-text => $text);
}

sub make_path {
    my($p) = @_;
    return if !$p;
    die "wrong arg for make_path: <$p>" if !$p->isa('Timex::Project');
    my @path = $p->path;
    join($separator, @path[1 .. $#path]);
}

sub get_entry {
    my($w) = @_;
    my $Ev = $w->XEvent;
    $w->GetNearest($Ev->y);
}

sub get_sel_entry {
    my $path = $project_frame->info('anchor');
    return $path if defined $path;
    $project_frame->info('selection');
}

sub entry_to_project {
    my($path) = @_;
    return if !defined $path;
    $project_frame->info('data', $path);
}

sub quit_program {
    require Tk::Dialog;
    if ($root->modified || defined $current_project) {
	if (!defined $quit_dialog) {
	    $quit_dialog = $top->Dialog(-title => 'Quit Program',
					-text  => "Really quit?\n" .
					($root->modified ?
					 "(modified data) " : "") .
					(defined $current_project ?
					 "(project running) " : ""),
					-default_button => 'No',
					-buttons => ['Yes', 'No'],
					-popover => 'cursor',
				       );
	}
	return 0 if $quit_dialog->Show ne 'Yes';
    }
    save_last_projects();
    $top->destroy;
}

sub sec2time {
    my($sec, $dateformat, $day8) = @_;
    $dateformat = $options->{'dateformat'} unless defined $dateformat;
    $day8       = $options->{'day8'}       unless defined $day8;
    my($day, $hour, $min);
    if ($dateformat eq 'd') {
	$day = int($sec / ($day8 ? 28800 : 86400));
	$sec = $sec % ($day8 ? 28800 : 86400);
    }
    $hour = int($sec / 3600);
    $sec  = $sec % 3600;
    $min  = int($sec / 60);
    if ($dateformat eq 'd') {
	sprintf("%3dd %02d:%02d", $day, $hour, $min);
    } elsif ($dateformat eq 'h') {
	sprintf("%3d:%02d", $hour, $min);
    } else {
	sprintf("%02d:%02d:%02d", $hour, $min, $sec % 60);
    }
}

sub check_still_today {
    my @new_nowtime = localtime;
    my $new_today_time = 
      time - $new_nowtime[0] - $new_nowtime[1]*60 - $new_nowtime[2]*60*60;
    if ($new_today_time != $today_time) {
	$today_time = $new_today_time;
	@nowtime = @new_nowtime;
	insert_all();
    }
}

# force appending .pj1 to filename
sub adjust_filename {
    my($file) = @_;
    if ($file !~ /\.pj1$/) {
	$file = "$file.pj1";
    }
    $file;
}


sub create_menu_last_projects {
    # find last separator
    my $end = $mb_file_menu->index('end');
    my $i = $end;
  LOOP: {
	while ($i >= 0) {
	    last LOOP if ($mb_file_menu->type($i) eq 'separator');
	    $i--;
	}
	$status_text->configure("Separator in Menu File not found");
	return;
    }
    # delete anything from the item after the separator to the end
    if ($i < $end) {
	$mb_file_menu->delete($i+1, 'end');
    }
    # insert last_projects
    $i = 0;
    foreach (@$last_projects) {
	my $pathname = $_;
	(my $out_pathname = $pathname) =~ s|$separator|/|g;
	$i++;
	$mb_file_menu->command(-label => "$i: " . $out_pathname,
			       -underline => 0,
			       -command => sub {
				   start_stop($pathname);
			       });
    }
}

sub add_last_projects {
    my($project) = @_;
    my $i;
    for($i = 0; $i <= $#$last_projects; $i++) {
	if ($last_projects->[$i] eq $project) {
	    splice @$last_projects, $i, 1;
	    last;
	}
    }
    unshift(@$last_projects, $project);
    if (@$last_projects > $max_last_projects) {
	$#$last_projects = $max_last_projects-1; # $max_last_projects Dateien merken
    }
}

sub load_last_projects {
    if (open(LAST, "$ENV{HOME}/.tktimex.last")) {
	$last_projects = [];
	$old_last_projects = [];
	while(<LAST>) {
	    chomp;
	    push @$last_projects, $_;
	    push @$old_last_projects, $_;
	}
	close LAST;
    }
}

sub last_projects_changed {
    my $i;
    for($i = 0; $i<=$#$last_projects; $i++) {
	return 1 if (!defined $old_last_projects->[$i]);
	return 1 if ($old_last_projects->[$i] ne $last_projects->[$i]);
    }
    0;
}

sub save_last_projects {
    return if !last_projects_changed();
    if (!open(LAST, ">$ENV{HOME}/.tktimex.last")) {
	$status_text->configure(-text => "Can't write to .tktimex.last");
	return;
    }
    $old_last_projects = [];
    foreach (@$last_projects) {
	print LAST "$_\n";
	push @$old_last_projects, $_;
    }
    close LAST;
}

sub show_about {
    my $dia = $top->Toplevel(-title => 'Copyright');
    $dia->Label(-text  => <<'EOF',

tktimex by Slaven Rezic (eserte@cs.tu-berlin.de)

Copyright (c) 1996-1998 Slaven Rezic. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software
   must display the following acknowledgement:
   This product includes software developed by Slaven Rezic.
4. The name of the author may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
		-justify => 'left')->pack;
    my $okb = $dia->Button(-text => 'OK',
			   -command => sub { $dia->destroy })->pack;
    $okb->focus;
    $dia->bind('<Escape>' => sub { $okb->invoke });
    $dia->Popup(-popover => 'cursor');
}

=head1 NAME

tktimex - project time manager

=head1 SYNOPSIS

    tktimex [options] [projectfile]

=head1 DESCRIPTION

B<tktimex> is a project time manager.

XXX

=head2 QUICK OVERVIEW

To create a new project, select from the B<Project> menu the item
B<New>.

To start the timer on a particular project, select the project from
the list and click on the B<Cont> button. To stop the timer, click on
the B<Pause> button.

If autosaving is on, after each click on B<Pause>, the project list
will be updated on disk, and so will every 10 minutes. If autosaving
is off, you have to manually save the project list by clicking on the
B<Save> button.

To reload an project list file, you have to specify the file name on
the command line:

	tktimex projectfile.pj1

If Tk::Getopt is installed on your system, you can set the default
project list file in the B<Option editor> (menu B<Options>).

=head1 OPTIONS

Possible options are:

        --file
        --[no]autosave   (default: 1) 
        --update         (default: 600) 
        --dateformat     (default: h) 
        --[no]day8
        --[no]archived
        --[no]onlytop
        --sort
        --[no]oneday-immediately         (default: 1)
        --geometry       (default: 500x230) 

=head1 TODO

- Pod

- View by day, by project, by interval, by month, by special attrib

- use getOpen/SaveFile or FBox instead of FileDialog

=head1 AUTHOR

Slaven Rezic (eserte@cs.tu-berlin.de)

Copyright (c) 1996-1998 Slaven Rezic. All rights reserved.

For a complete copyright see the Help/About menu entry.

=cut
